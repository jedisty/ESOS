!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLOC_LEFT	./segment.h	/^	ALLOC_LEFT$/;"	e	enum:__anon9
ALLOC_NODE	./f2fs.h	/^	ALLOC_NODE,			\/* allocate a new node page if needed *\/$/;"	e	enum:__anon5
ALLOC_RIGHT	./segment.h	/^	ALLOC_RIGHT = 0,$/;"	e	enum:__anon9
APPEND_INO	./f2fs.h	/^	APPEND_INO,		\/* for append ino list *\/$/;"	e	enum:__anon4
ATTR_LIST	./super.c	198;"	d	file:
BG_GC	./segment.h	/^	BG_GC = 0,$/;"	e	enum:__anon12
CP_DISCARD	./f2fs.h	/^	CP_DISCARD,$/;"	e	enum:__anon2
CP_SYNC	./f2fs.h	/^	CP_SYNC,$/;"	e	enum:__anon2
CP_UMOUNT	./f2fs.h	/^	CP_UMOUNT,$/;"	e	enum:__anon2
CRCPOLY_LE	./f2fs.h	70;"	d
CREATE_TRACE_POINTS	./super.c	34;"	d	file:
CURSEG_COLD_DATA	./f2fs.h	/^	CURSEG_COLD_DATA,	\/* multimedia or GCed data blocks *\/$/;"	e	enum:__anon6
CURSEG_COLD_NODE	./f2fs.h	/^	CURSEG_COLD_NODE,	\/* indirect node blocks *\/$/;"	e	enum:__anon6
CURSEG_HOT_DATA	./f2fs.h	/^	CURSEG_HOT_DATA	= 0,	\/* directory entry blocks *\/$/;"	e	enum:__anon6
CURSEG_HOT_NODE	./f2fs.h	/^	CURSEG_HOT_NODE,	\/* direct node blocks of directory files *\/$/;"	e	enum:__anon6
CURSEG_I	./segment.h	/^static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)$/;"	f
CURSEG_WARM_DATA	./f2fs.h	/^	CURSEG_WARM_DATA,	\/* data blocks *\/$/;"	e	enum:__anon6
CURSEG_WARM_NODE	./f2fs.h	/^	CURSEG_WARM_NODE,	\/* direct node blocks of normal files *\/$/;"	e	enum:__anon6
DATA	./f2fs.h	/^	DATA,$/;"	e	enum:page_type
DEF_DIR_LEVEL	./f2fs.h	250;"	d
DEF_GC_THREAD_MAX_SLEEP_TIME	./gc.h	17;"	d
DEF_GC_THREAD_MIN_SLEEP_TIME	./gc.h	16;"	d
DEF_GC_THREAD_NOGC_SLEEP_TIME	./gc.h	18;"	d
DEF_MAX_VICTIM_SEARCH	./gc.h	23;"	d
DEF_MIN_FSYNC_BLOCKS	./segment.h	501;"	d
DEF_MIN_IPU_UTIL	./segment.h	500;"	d
DEF_RAM_THRESHOLD	./node.h	24;"	d
DEF_RECLAIM_PREFREE_SEGMENTS	./segment.h	22;"	d
DELTA	./hash.c	26;"	d	file:
DIRTY	./segment.h	/^	DIRTY,			\/* to count # of dirty segments *\/$/;"	e	enum:dirty_type
DIRTY_COLD_DATA	./segment.h	/^	DIRTY_COLD_DATA,	\/* dirty segments assigned as cold data logs *\/$/;"	e	enum:dirty_type
DIRTY_COLD_NODE	./segment.h	/^	DIRTY_COLD_NODE,	\/* dirty segments assigned as cold node logs *\/$/;"	e	enum:dirty_type
DIRTY_DENTS	./node.h	/^	DIRTY_DENTS	\/* indicates dirty dentry pages *\/$/;"	e	enum:mem_type
DIRTY_HOT_DATA	./segment.h	/^	DIRTY_HOT_DATA,		\/* dirty segments assigned as hot data logs *\/$/;"	e	enum:dirty_type
DIRTY_HOT_NODE	./segment.h	/^	DIRTY_HOT_NODE,		\/* dirty segments assigned as hot node logs *\/$/;"	e	enum:dirty_type
DIRTY_I	./f2fs.h	/^static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)$/;"	f
DIRTY_WARM_DATA	./segment.h	/^	DIRTY_WARM_DATA,	\/* dirty segments assigned as warm data logs *\/$/;"	e	enum:dirty_type
DIRTY_WARM_NODE	./segment.h	/^	DIRTY_WARM_NODE,	\/* dirty segments assigned as warm node logs *\/$/;"	e	enum:dirty_type
ENTRY_SIZE	./xattr.h	59;"	d
F2FS_ACL_VERSION	./acl.h	20;"	d
F2FS_ATTR_OFFSET	./super.c	171;"	d	file:
F2FS_CKPT	./f2fs.h	/^static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)$/;"	f
F2FS_DA_MAP	./segment.h	14;"	d
F2FS_DEFAULT_ALLOCATED_BLOCKS	./f2fs.h	722;"	d
F2FS_DIRTY_DENTS	./f2fs.h	/^	F2FS_DIRTY_DENTS,$/;"	e	enum:count_type
F2FS_DIRTY_META	./f2fs.h	/^	F2FS_DIRTY_META,$/;"	e	enum:count_type
F2FS_DIRTY_NODES	./f2fs.h	/^	F2FS_DIRTY_NODES,$/;"	e	enum:count_type
F2FS_HAS_BLOCKS	./f2fs.h	/^static inline int F2FS_HAS_BLOCKS(struct inode *inode)$/;"	f
F2FS_I	./f2fs.h	/^static inline struct f2fs_inode_info *F2FS_I(struct inode *inode)$/;"	f
F2FS_INODE	./f2fs.h	/^static inline struct f2fs_inode *F2FS_INODE(struct page *page)$/;"	f
F2FS_IOC32_GETFLAGS	./f2fs.h	207;"	d
F2FS_IOC32_SETFLAGS	./f2fs.h	208;"	d
F2FS_IOCTL_MAGIC	./f2fs.h	198;"	d
F2FS_IOC_COMMIT_ATOMIC_WRITE	./f2fs.h	200;"	d
F2FS_IOC_GETFLAGS	./f2fs.h	195;"	d
F2FS_IOC_SETFLAGS	./f2fs.h	196;"	d
F2FS_IOC_START_ATOMIC_WRITE	./f2fs.h	199;"	d
F2FS_IOC_START_VOLATILE_WRITE	./f2fs.h	201;"	d
F2FS_IPU_DISABLE	./segment.h	/^	F2FS_IPU_DISABLE,$/;"	e	enum:__anon13
F2FS_IPU_FORCE	./segment.h	/^	F2FS_IPU_FORCE,$/;"	e	enum:__anon13
F2FS_IPU_FSYNC	./segment.h	/^	F2FS_IPU_FSYNC,$/;"	e	enum:__anon13
F2FS_IPU_SSR	./segment.h	/^	F2FS_IPU_SSR,$/;"	e	enum:__anon13
F2FS_IPU_SSR_UTIL	./segment.h	/^	F2FS_IPU_SSR_UTIL,$/;"	e	enum:__anon13
F2FS_IPU_UTIL	./segment.h	/^	F2FS_IPU_UTIL,$/;"	e	enum:__anon13
F2FS_I_SB	./f2fs.h	/^static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)$/;"	f
F2FS_LINK_MAX	./f2fs.h	230;"	d
F2FS_MIN_EXTENT_LEN	./f2fs.h	235;"	d
F2FS_MOUNT_BG_GC	./f2fs.h	40;"	d
F2FS_MOUNT_DISABLE_EXT_IDENTIFY	./f2fs.h	46;"	d
F2FS_MOUNT_DISABLE_ROLL_FORWARD	./f2fs.h	41;"	d
F2FS_MOUNT_DISCARD	./f2fs.h	42;"	d
F2FS_MOUNT_FLUSH_MERGE	./f2fs.h	49;"	d
F2FS_MOUNT_INLINE_DATA	./f2fs.h	48;"	d
F2FS_MOUNT_INLINE_XATTR	./f2fs.h	47;"	d
F2FS_MOUNT_NOBARRIER	./f2fs.h	50;"	d
F2FS_MOUNT_NOHEAP	./f2fs.h	43;"	d
F2FS_MOUNT_POSIX_ACL	./f2fs.h	45;"	d
F2FS_MOUNT_XATTR_USER	./f2fs.h	44;"	d
F2FS_M_SB	./f2fs.h	/^static inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)$/;"	f
F2FS_NODE	./f2fs.h	/^static inline struct f2fs_node *F2FS_NODE(struct page *page)$/;"	f
F2FS_OTHER_FLMASK	./file.c	796;"	d	file:
F2FS_P_SB	./f2fs.h	/^static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)$/;"	f
F2FS_RAW_SUPER	./f2fs.h	/^static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)$/;"	f
F2FS_REG_FLMASK	./file.c	795;"	d	file:
F2FS_RESET_SB_DIRT	./f2fs.h	/^static inline void F2FS_RESET_SB_DIRT(struct f2fs_sb_info *sbi)$/;"	f
F2FS_RW_ATTR	./super.c	180;"	d	file:
F2FS_SB	./f2fs.h	/^static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)$/;"	f
F2FS_SBI	./super.c	/^	F2FS_SBI,	\/* struct f2fs_sb_info *\/$/;"	e	enum:__anon15	file:
F2FS_SET_SB_DIRT	./f2fs.h	/^static inline void F2FS_SET_SB_DIRT(struct f2fs_sb_info *sbi)$/;"	f
F2FS_STAT	./f2fs.h	/^static inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)$/;"	f
F2FS_SYSTEM_ADVISE_PREFIX	./xattr.h	30;"	d
F2FS_WRITEBACK	./f2fs.h	/^	F2FS_WRITEBACK,$/;"	e	enum:count_type
F2FS_XATTR_INDEX_ADVISE	./xattr.h	37;"	d
F2FS_XATTR_INDEX_LUSTRE	./xattr.h	35;"	d
F2FS_XATTR_INDEX_POSIX_ACL_ACCESS	./xattr.h	32;"	d
F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT	./xattr.h	33;"	d
F2FS_XATTR_INDEX_SECURITY	./xattr.h	36;"	d
F2FS_XATTR_INDEX_TRUSTED	./xattr.h	34;"	d
F2FS_XATTR_INDEX_USER	./xattr.h	31;"	d
F2FS_XATTR_MAGIC	./xattr.h	24;"	d
F2FS_XATTR_REFCOUNT_MAX	./xattr.h	27;"	d
FADVISE_COLD_BIT	./f2fs.h	247;"	d
FADVISE_LOST_PINO_BIT	./f2fs.h	248;"	d
FG_GC	./segment.h	/^	FG_GC$/;"	e	enum:__anon12
FI_ACL_MODE	./f2fs.h	/^	FI_ACL_MODE,		\/* indicate acl mode *\/$/;"	e	enum:__anon7
FI_APPEND_WRITE	./f2fs.h	/^	FI_APPEND_WRITE,	\/* inode has appended data *\/$/;"	e	enum:__anon7
FI_ATOMIC_FILE	./f2fs.h	/^	FI_ATOMIC_FILE,		\/* indicate atomic file *\/$/;"	e	enum:__anon7
FI_DELAY_IPUT	./f2fs.h	/^	FI_DELAY_IPUT,		\/* used for the recovery *\/$/;"	e	enum:__anon7
FI_DIRTY_DIR	./f2fs.h	/^	FI_DIRTY_DIR,		\/* indicate directory has dirty pages *\/$/;"	e	enum:__anon7
FI_DIRTY_INODE	./f2fs.h	/^	FI_DIRTY_INODE,		\/* indicate inode is dirty or not *\/$/;"	e	enum:__anon7
FI_INC_LINK	./f2fs.h	/^	FI_INC_LINK,		\/* need to increment i_nlink *\/$/;"	e	enum:__anon7
FI_INLINE_DATA	./f2fs.h	/^	FI_INLINE_DATA,		\/* used for inline data*\/$/;"	e	enum:__anon7
FI_INLINE_XATTR	./f2fs.h	/^	FI_INLINE_XATTR,	\/* used for inline xattr *\/$/;"	e	enum:__anon7
FI_NEED_IPU	./f2fs.h	/^	FI_NEED_IPU,		\/* used for ipu per file *\/$/;"	e	enum:__anon7
FI_NEW_INODE	./f2fs.h	/^	FI_NEW_INODE,		\/* indicate newly allocated inode *\/$/;"	e	enum:__anon7
FI_NO_ALLOC	./f2fs.h	/^	FI_NO_ALLOC,		\/* should not allocate any blocks *\/$/;"	e	enum:__anon7
FI_NO_EXTENT	./f2fs.h	/^	FI_NO_EXTENT,		\/* not to use the extent cache *\/$/;"	e	enum:__anon7
FI_UPDATE_DIR	./f2fs.h	/^	FI_UPDATE_DIR,		\/* should update inode block for consistency *\/$/;"	e	enum:__anon7
FI_UPDATE_WRITE	./f2fs.h	/^	FI_UPDATE_WRITE,	\/* inode has in-place-update data *\/$/;"	e	enum:__anon7
FI_VOLATILE_FILE	./f2fs.h	/^	FI_VOLATILE_FILE,	\/* indicate volatile file *\/$/;"	e	enum:__anon7
FREE_I	./f2fs.h	/^static inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)$/;"	f
FREE_NIDS	./node.h	/^	FREE_NIDS,	\/* indicates the free nid list *\/$/;"	e	enum:mem_type
FREE_NID_PAGES	./node.h	18;"	d
GC_CB	./segment.h	/^	GC_CB = 0,$/;"	e	enum:__anon11
GC_GREEDY	./segment.h	/^	GC_GREEDY$/;"	e	enum:__anon11
GC_THREAD	./super.c	/^	GC_THREAD,	\/* struct f2fs_gc_thread *\/$/;"	e	enum:__anon15	file:
GC_THREAD_MIN_WB_PAGES	./gc.h	11;"	d
GET_BLKOFF_FROM_SEG0	./segment.h	75;"	d
GET_L2R_SEGNO	./segment.h	25;"	d
GET_R2L_SEGNO	./segment.h	26;"	d
GET_SECNO	./segment.h	82;"	d
GET_SEGNO	./segment.h	78;"	d
GET_SEGNO_FROM_SEG0	./segment.h	73;"	d
GET_SEGOFF_FROM_SEG0	./segment.h	72;"	d
GET_SUM_BLOCK	./segment.h	87;"	d
GET_SUM_TYPE	./segment.h	90;"	d
GET_ZONENO_FROM_SEGNO	./segment.h	84;"	d
HAS_FSYNCED_INODE	./node.h	/^	HAS_FSYNCED_INODE,	\/* is the inode fsynced before? *\/$/;"	e	enum:__anon8
HAS_LAST_FSYNC	./node.h	/^	HAS_LAST_FSYNC,		\/* has the latest node fsync mark? *\/$/;"	e	enum:__anon8
IS_CHECKPOINTED	./node.h	/^	IS_CHECKPOINTED,	\/* is it checkpointed before? *\/$/;"	e	enum:__anon8
IS_CURSEC	./segment.h	39;"	d
IS_CURSEG	./segment.h	31;"	d
IS_DATASEG	./segment.h	28;"	d
IS_DIRTY	./node.h	/^	IS_DIRTY,		\/* this nat entry is dirty? *\/$/;"	e	enum:__anon8
IS_DNODE	./node.h	/^static inline bool IS_DNODE(struct page *node_page)$/;"	f
IS_INODE	./f2fs.h	/^static inline bool IS_INODE(struct page *page)$/;"	f
IS_NODESEG	./segment.h	29;"	d
IS_XATTR_LAST_ENTRY	./xattr.h	65;"	d
LFS	./segment.h	/^	LFS = 0,$/;"	e	enum:__anon10
LIMIT_FREE_BLOCK	./gc.h	20;"	d
LIMIT_INVALID_BLOCK	./gc.h	19;"	d
LOCKED_PAGE	./node.h	30;"	d
LOOKUP_NODE	./f2fs.h	/^	LOOKUP_NODE,			\/* look up a node without readahead *\/$/;"	e	enum:__anon5
LOOKUP_NODE_RA	./f2fs.h	/^	LOOKUP_NODE_RA,			\/*$/;"	e	enum:__anon5
MAIN_BLKADDR	./segment.h	53;"	d
MAIN_SECS	./segment.h	57;"	d
MAIN_SEGS	./segment.h	56;"	d
MAX_BIO_BLOCKS	./segment.h	108;"	d
MAX_BLKADDR	./segment.h	62;"	d
MAX_DIR_RA_PAGES	./f2fs.h	232;"	d
MAX_INO_ENTRY	./f2fs.h	/^	MAX_INO_ENTRY,		\/* max. list *\/$/;"	e	enum:__anon4
MAX_NAT_JENTRIES	./f2fs.h	167;"	d
MAX_RA_NODE	./node.h	21;"	d
MAX_SIT_JENTRIES	./f2fs.h	168;"	d
MAX_VALUE_LEN	./xattr.h	75;"	d
META	./f2fs.h	/^	META,$/;"	e	enum:page_type
META_CP	./f2fs.h	/^	META_CP,$/;"	e	enum:__anon3
META_FLUSH	./f2fs.h	/^	META_FLUSH,$/;"	e	enum:page_type
META_MAPPING	./f2fs.h	/^static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)$/;"	f
META_NAT	./f2fs.h	/^	META_NAT,$/;"	e	enum:__anon3
META_POR	./f2fs.h	/^	META_POR,$/;"	e	enum:__anon3
META_SIT	./f2fs.h	/^	META_SIT,$/;"	e	enum:__anon3
META_SSA	./f2fs.h	/^	META_SSA,$/;"	e	enum:__anon3
MIN_OFFSET	./xattr.h	72;"	d
NAND_PAGE_SIZE	./segment.h	15;"	d
NATVEC_SIZE	./node.h	27;"	d
NAT_BITMAP	./f2fs.h	/^	NAT_BITMAP,$/;"	e	enum:__anon1
NAT_BLOCK_OFFSET	./node.h	15;"	d
NAT_ENTRIES	./node.h	/^	NAT_ENTRIES,	\/* indicates the cached nat entry *\/$/;"	e	enum:mem_type
NEXT_FREE_BLKADDR	./segment.h	69;"	d
NID_ALLOC	./node.h	/^	NID_ALLOC	\/* it is allocated *\/$/;"	e	enum:nid_state
NID_NEW	./node.h	/^	NID_NEW,	\/* newly added to free nid list *\/$/;"	e	enum:nid_state
NM_I	./f2fs.h	/^static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)$/;"	f
NM_INFO	./super.c	/^	NM_INFO,	\/* struct f2fs_nm_info *\/$/;"	e	enum:__anon15	file:
NODE	./f2fs.h	/^	NODE,$/;"	e	enum:page_type
NODE_MAPPING	./f2fs.h	/^static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)$/;"	f
NO_CHECK_TYPE	./f2fs.h	/^	NO_CHECK_TYPE$/;"	e	enum:__anon6
NR_COUNT_TYPE	./f2fs.h	/^	NR_COUNT_TYPE,$/;"	e	enum:count_type
NR_CURSEG_DATA_TYPE	./f2fs.h	361;"	d
NR_CURSEG_NODE_TYPE	./f2fs.h	362;"	d
NR_CURSEG_TYPE	./f2fs.h	363;"	d
NR_DIRTY_TYPE	./segment.h	/^	NR_DIRTY_TYPE$/;"	e	enum:dirty_type
NR_PAGE_TYPE	./f2fs.h	/^	NR_PAGE_TYPE,$/;"	e	enum:page_type
NULL_SECNO	./segment.h	20;"	d
NULL_SEGNO	./segment.h	19;"	d
N_PAGE_ALIGN	./segment.h	16;"	d
ORPHAN_INO	./f2fs.h	/^	ORPHAN_INO,		\/* for orphan ino list *\/$/;"	e	enum:__anon4
Opt_acl	./super.c	/^	Opt_acl,$/;"	e	enum:__anon14	file:
Opt_active_logs	./super.c	/^	Opt_active_logs,$/;"	e	enum:__anon14	file:
Opt_disable_ext_identify	./super.c	/^	Opt_disable_ext_identify,$/;"	e	enum:__anon14	file:
Opt_disable_roll_forward	./super.c	/^	Opt_disable_roll_forward,$/;"	e	enum:__anon14	file:
Opt_discard	./super.c	/^	Opt_discard,$/;"	e	enum:__anon14	file:
Opt_err	./super.c	/^	Opt_err,$/;"	e	enum:__anon14	file:
Opt_flush_merge	./super.c	/^	Opt_flush_merge,$/;"	e	enum:__anon14	file:
Opt_gc_background	./super.c	/^	Opt_gc_background,$/;"	e	enum:__anon14	file:
Opt_inline_data	./super.c	/^	Opt_inline_data,$/;"	e	enum:__anon14	file:
Opt_inline_xattr	./super.c	/^	Opt_inline_xattr,$/;"	e	enum:__anon14	file:
Opt_noacl	./super.c	/^	Opt_noacl,$/;"	e	enum:__anon14	file:
Opt_nobarrier	./super.c	/^	Opt_nobarrier,$/;"	e	enum:__anon14	file:
Opt_noheap	./super.c	/^	Opt_noheap,$/;"	e	enum:__anon14	file:
Opt_nouser_xattr	./super.c	/^	Opt_nouser_xattr,$/;"	e	enum:__anon14	file:
Opt_user_xattr	./super.c	/^	Opt_user_xattr,$/;"	e	enum:__anon14	file:
PAGE_TYPE_OF_BIO	./f2fs.h	450;"	d
PGOFS_OF_NEXT_DNODE	./f2fs.h	1188;"	d
PRE	./segment.h	/^	PRE,			\/* to count # of entirely obsolete segments *\/$/;"	e	enum:dirty_type
RAW_IS_INODE	./f2fs.h	991;"	d
SECTOR_FROM_BLOCK	./segment.h	104;"	d
SECTOR_TO_BLOCK	./segment.h	106;"	d
SEG0_BLKADDR	./segment.h	54;"	d
SEGMENT_SIZE	./segment.h	63;"	d
SET_SUM_TYPE	./segment.h	91;"	d
SIT_BITMAP	./f2fs.h	/^	SIT_BITMAP$/;"	e	enum:__anon1
SIT_BLK_CNT	./segment.h	99;"	d
SIT_BLOCK_OFFSET	./segment.h	95;"	d
SIT_ENTRY_OFFSET	./segment.h	93;"	d
SIT_I	./f2fs.h	/^static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)$/;"	f
SM_I	./f2fs.h	/^static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)$/;"	f
SM_INFO	./super.c	/^	SM_INFO,	\/* struct f2fs_sm_info *\/$/;"	e	enum:__anon15	file:
SSR	./segment.h	/^	SSR$/;"	e	enum:__anon10
START_BLOCK	./segment.h	66;"	d
START_NID	./node.h	12;"	d
START_SEGNO	./segment.h	97;"	d
S_SHIFT	./dir.c	51;"	d	file:
TEA_transform	./hash.c	/^static void TEA_transform(unsigned int buf[4], unsigned int const in[])$/;"	f	file:
TOTAL_BLKS	./segment.h	60;"	d
TOTAL_SEGS	./segment.h	59;"	d
UPDATE_INO	./f2fs.h	/^	UPDATE_INO,		\/* for update ino list *\/$/;"	e	enum:__anon4
XATTR_ALIGN	./xattr.h	57;"	d
XATTR_ENTRY	./xattr.h	53;"	d
XATTR_FIRST_ENTRY	./xattr.h	54;"	d
XATTR_HDR	./xattr.h	52;"	d
XATTR_NEXT_ENTRY	./xattr.h	62;"	d
XATTR_NODE_OFFSET	./f2fs.h	219;"	d
XATTR_ROUND	./xattr.h	55;"	d
_LINUX_F2FS_H	./f2fs.h	12;"	d
__F2FS_ACL_H__	./acl.h	16;"	d
__F2FS_XATTR_H__	./xattr.h	18;"	d
__add_dirty_inode	./checkpoint.c	/^static int __add_dirty_inode(struct inode *inode, struct dir_inode_entry *new)$/;"	f	file:
__add_ino_entry	./checkpoint.c	/^static void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)$/;"	f	file:
__add_sum_entry	./segment.c	/^static void __add_sum_entry(struct f2fs_sb_info *sbi, int type,$/;"	f	file:
__adjust_nat_entry_set	./node.c	/^static void __adjust_nat_entry_set(struct nat_entry_set *nes,$/;"	f	file:
__allocate_data_block	./data.c	/^static int __allocate_data_block(struct dnode_of_data *dn)$/;"	f	file:
__bio_alloc	./data.c	/^static struct bio *__bio_alloc(struct f2fs_sb_info *sbi, block_t blk_addr,$/;"	f	file:
__bitmap_ptr	./f2fs.h	/^static inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)$/;"	f
__bitmap_size	./f2fs.h	/^static inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)$/;"	f
__clear_nat_cache_dirty	./node.c	/^static void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,$/;"	f	file:
__del_from_free_nid_list	./node.c	/^static void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,$/;"	f	file:
__del_from_nat_cache	./node.c	/^static void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)$/;"	f	file:
__f2fs_add_link	./dir.c	/^int __f2fs_add_link(struct inode *dir, const struct qstr *name,$/;"	f
__f2fs_convert_inline_data	./inline.c	/^static int __f2fs_convert_inline_data(struct inode *inode, struct page *page)$/;"	f	file:
__f2fs_set_acl	./acl.c	/^static int __f2fs_set_acl(struct inode *inode, int type,$/;"	f	file:
__f2fs_setxattr	./xattr.c	/^static int __f2fs_setxattr(struct inode *inode, int index,$/;"	f	file:
__f2fs_writepage	./data.c	/^static int __f2fs_writepage(struct page *page, struct writeback_control *wbc,$/;"	f	file:
__find_rev_next_bit	./segment.c	/^static unsigned long __find_rev_next_bit(const unsigned long *addr,$/;"	f	file:
__find_rev_next_zero_bit	./segment.c	/^static unsigned long __find_rev_next_zero_bit(const unsigned long *addr,$/;"	f	file:
__find_xattr	./xattr.c	/^static struct f2fs_xattr_entry *__find_xattr(void *base_addr, int index,$/;"	f	file:
__flush_nat_entry_set	./node.c	/^static void __flush_nat_entry_set(struct f2fs_sb_info *sbi,$/;"	f	file:
__found_offset	./file.c	/^static bool __found_offset(block_t blkaddr, pgoff_t dirty, pgoff_t pgofs,$/;"	f	file:
__gang_lookup_nat_cache	./node.c	/^static unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,$/;"	f	file:
__gang_lookup_nat_set	./node.c	/^static unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,$/;"	f	file:
__get_data_block	./data.c	/^static int __get_data_block(struct inode *inode, sector_t iblock,$/;"	f	file:
__get_first_dirty_index	./file.c	/^static pgoff_t __get_first_dirty_index(struct address_space *mapping,$/;"	f	file:
__get_inode_rdev	./inode.c	/^static void __get_inode_rdev(struct inode *inode, struct f2fs_inode *ri)$/;"	f	file:
__get_segment_type	./segment.c	/^static int __get_segment_type(struct page *page, enum page_type p_type)$/;"	f	file:
__get_segment_type_2	./segment.c	/^static int __get_segment_type_2(struct page *page, enum page_type p_type)$/;"	f	file:
__get_segment_type_4	./segment.c	/^static int __get_segment_type_4(struct page *page, enum page_type p_type)$/;"	f	file:
__get_segment_type_6	./segment.c	/^static int __get_segment_type_6(struct page *page, enum page_type p_type)$/;"	f	file:
__get_victim	./gc.c	/^static int __get_victim(struct f2fs_sb_info *sbi, unsigned int *victim,$/;"	f	file:
__has_curseg_space	./segment.c	/^static bool __has_curseg_space(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
__has_cursum_space	./f2fs.h	/^static inline bool __has_cursum_space(struct f2fs_summary_block *sum, int size,$/;"	f
__locate_dirty_segment	./segment.c	/^static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,$/;"	f	file:
__lookup_free_nid_list	./node.c	/^static struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,$/;"	f	file:
__lookup_nat_cache	./node.c	/^static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)$/;"	f	file:
__mark_sit_entry_dirty	./segment.c	/^static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f	file:
__next_free_blkoff	./segment.c	/^static void __next_free_blkoff(struct f2fs_sb_info *sbi,$/;"	f	file:
__refresh_next_blkoff	./segment.c	/^static void __refresh_next_blkoff(struct f2fs_sb_info *sbi,$/;"	f	file:
__remove_dirty_segment	./segment.c	/^static void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,$/;"	f	file:
__remove_ino_entry	./checkpoint.c	/^static void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)$/;"	f	file:
__reverse_ffs	./segment.c	/^static inline unsigned long __reverse_ffs(unsigned long word)$/;"	f	file:
__reverse_ffz	./segment.c	29;"	d	file:
__set_data_blkaddr	./data.c	/^static void __set_data_blkaddr(struct dnode_of_data *dn, block_t new_addr)$/;"	f	file:
__set_free	./segment.h	/^static inline void __set_free(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f
__set_inode_rdev	./inode.c	/^static void __set_inode_rdev(struct inode *inode, struct f2fs_inode *ri)$/;"	f	file:
__set_inuse	./segment.h	/^static inline void __set_inuse(struct f2fs_sb_info *sbi,$/;"	f
__set_nat_cache_dirty	./node.c	/^static void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,$/;"	f	file:
__set_sit_entry_type	./segment.c	/^static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,$/;"	f	file:
__set_test_and_free	./segment.h	/^static inline void __set_test_and_free(struct f2fs_sb_info *sbi,$/;"	f
__set_test_and_inuse	./segment.h	/^static inline void __set_test_and_inuse(struct f2fs_sb_info *sbi,$/;"	f
__setattr_copy	./file.c	/^static void __setattr_copy(struct inode *inode, const struct iattr *attr)$/;"	f	file:
__setattr_copy	./file.c	550;"	d	file:
__start_cp_addr	./f2fs.h	/^static inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)$/;"	f
__start_sum_addr	./f2fs.h	/^static inline block_t __start_sum_addr(struct f2fs_sb_info *sbi)$/;"	f
__struct_ptr	./super.c	/^static unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)$/;"	f	file:
__submit_merged_bio	./data.c	/^static void __submit_merged_bio(struct f2fs_bio_info *io)$/;"	f	file:
__this_module	./f2fs.mod.c	/^__visible struct module __this_module$/;"	v	typeref:struct:module
__used	./f2fs.mod.c	/^__used$/;"	v	file:
__used	./f2fs.mod.c	/^__used$/;"	v	typeref:struct:____versions	file:
a_version	./acl.h	/^	__le32 a_version;$/;"	m	struct:f2fs_acl_header
acquire_orphan_inode	./checkpoint.c	/^int acquire_orphan_inode(struct f2fs_sb_info *sbi)$/;"	f
active_logs	./f2fs.h	/^	int active_logs;			\/* # of active logs *\/$/;"	m	struct:f2fs_sb_info
add_dirty_dir_inode	./checkpoint.c	/^void add_dirty_dir_inode(struct inode *inode)$/;"	f
add_dirty_inode	./checkpoint.c	/^void add_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)$/;"	f
add_discard_addrs	./segment.c	/^static void add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f	file:
add_free_nid	./node.c	/^static int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)$/;"	f	file:
add_gc_inode	./gc.c	/^static void add_gc_inode(struct inode *inode, struct list_head *ilist)$/;"	f	file:
add_orphan_inode	./checkpoint.c	/^void add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f
add_sit_entry	./segment.c	/^static void add_sit_entry(unsigned int segno, struct list_head *head)$/;"	f	file:
add_sits_in_set	./segment.c	/^static void add_sits_in_set(struct f2fs_sb_info *sbi)$/;"	f	file:
addrs_per_inode	./f2fs.h	/^static inline unsigned int addrs_per_inode(struct f2fs_inode_info *fi)$/;"	f
adjust_sit_entry_set	./segment.c	/^static void adjust_sit_entry_set(struct sit_entry_set *ses,$/;"	f	file:
all_area_segs	./f2fs.h	/^	int all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;$/;"	m	struct:f2fs_stat_info
alloc_mode	./segment.h	/^	int alloc_mode;			\/* LFS or SSR *\/$/;"	m	struct:victim_sel_policy
alloc_nid	./node.c	/^bool alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid)$/;"	f
alloc_nid_done	./node.c	/^void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
alloc_nid_failed	./node.c	/^void alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
alloc_type	./segment.h	/^	unsigned char alloc_type;		\/* current allocation type *\/$/;"	m	struct:curseg_info
alloc_valid_block_count	./f2fs.h	/^	block_t alloc_valid_block_count;	\/* # of allocated blocks *\/$/;"	m	struct:f2fs_sb_info
allocate_data_block	./segment.c	/^void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,$/;"	f
allocate_dummy_data_block	./segment.c	/^void allocate_dummy_data_block(struct f2fs_sb_info *sbi, struct page *page,$/;"	f
allocate_new_segments	./segment.c	/^void allocate_new_segments(struct f2fs_sb_info *sbi)$/;"	f
allocate_segment	./segment.h	/^	void (*allocate_segment)(struct f2fs_sb_info *, int, bool);$/;"	m	struct:segment_allocation
allocate_segment_by_default	./segment.c	/^static void allocate_segment_by_default(struct f2fs_sb_info *sbi,$/;"	f	file:
attr	./super.c	/^	struct attribute attr;$/;"	m	struct:f2fs_attr	typeref:struct:f2fs_attr::attribute	file:
available_free_memory	./node.c	/^bool available_free_memory(struct f2fs_sb_info *sbi, int type)$/;"	f
available_nids	./f2fs.h	/^	nid_t available_nids;		\/* maximum available node ids *\/$/;"	m	struct:f2fs_nm_info
avg_vblocks	./f2fs.h	/^	unsigned int bimodal, avg_vblocks;$/;"	m	struct:f2fs_stat_info
base_mem	./f2fs.h	/^	unsigned base_mem, cache_mem;$/;"	m	struct:f2fs_stat_info
bg_gc	./f2fs.h	/^	int bg_gc, inline_inode;$/;"	m	struct:f2fs_stat_info
bg_gc	./f2fs.h	/^	int bg_gc;				\/* background gc calls *\/$/;"	m	struct:f2fs_sb_info
bimodal	./f2fs.h	/^	unsigned int bimodal, avg_vblocks;$/;"	m	struct:f2fs_stat_info
bio	./f2fs.h	/^	struct bio *bio;		\/* bios to merge *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::bio
bitmap_size	./f2fs.h	/^	int bitmap_size;		\/* bitmap size *\/$/;"	m	struct:f2fs_nm_info
bitmap_size	./segment.h	/^	unsigned int bitmap_size;	\/* SIT bitmap size *\/$/;"	m	struct:sit_info
blk_addr	./f2fs.h	/^	u32 blk_addr;		\/* start block address of the extent *\/$/;"	m	struct:extent_info
blk_addr	./node.h	/^	block_t	blk_addr;	\/* block address of the node *\/$/;"	m	struct:node_info
blkaddr	./f2fs.h	/^	block_t blkaddr;	\/* block address locating the last fsync *\/$/;"	m	struct:fsync_inode_entry
blkaddr	./f2fs.h	/^	block_t blkaddr;	\/* block address to be discarded *\/$/;"	m	struct:discard_entry
blkaddr_in_node	./f2fs.h	/^static inline __le32 *blkaddr_in_node(struct f2fs_node *node)$/;"	f
block_count	./f2fs.h	/^	unsigned int block_count[2];		\/* # of allocated blocks *\/$/;"	m	struct:f2fs_sb_info
block_count	./f2fs.h	/^	unsigned int block_count[2];$/;"	m	struct:f2fs_stat_info
block_operations	./checkpoint.c	/^static int block_operations(struct f2fs_sb_info *sbi)$/;"	f	file:
block_t	./f2fs.h	/^typedef u32 block_t;	\/*$/;"	t
blocks_per_seg	./f2fs.h	/^	unsigned int blocks_per_seg;		\/* blocks per segment *\/$/;"	m	struct:f2fs_sb_info
blocksize	./f2fs.h	/^	unsigned int blocksize;			\/* block size *\/$/;"	m	struct:f2fs_sb_info
bucket_blocks	./dir.c	/^static unsigned int bucket_blocks(unsigned int level)$/;"	f	file:
build_curseg	./segment.c	/^static int build_curseg(struct f2fs_sb_info *sbi)$/;"	f	file:
build_dirty_segmap	./segment.c	/^static int build_dirty_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
build_free_nids	./node.c	/^static void build_free_nids(struct f2fs_sb_info *sbi)$/;"	f	file:
build_free_segmap	./segment.c	/^static int build_free_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
build_gc_manager	./gc.c	/^void build_gc_manager(struct f2fs_sb_info *sbi)$/;"	f
build_lock	./f2fs.h	/^	struct mutex build_lock;	\/* lock for build free nids *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::mutex
build_node_manager	./node.c	/^int build_node_manager(struct f2fs_sb_info *sbi)$/;"	f
build_segment_manager	./segment.c	/^int build_segment_manager(struct f2fs_sb_info *sbi)$/;"	f
build_sit_entries	./segment.c	/^static void build_sit_entries(struct f2fs_sb_info *sbi)$/;"	f	file:
build_sit_info	./segment.c	/^static int build_sit_info(struct f2fs_sb_info *sbi)$/;"	f	file:
cache_mem	./f2fs.h	/^	unsigned base_mem, cache_mem;$/;"	m	struct:f2fs_stat_info
cache_nat_entry	./node.c	/^static void cache_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid,$/;"	f	file:
call_count	./f2fs.h	/^	int prefree_count, call_count, cp_count;$/;"	m	struct:f2fs_stat_info
change_curseg	./segment.c	/^static void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)$/;"	f	file:
chash	./f2fs.h	/^	f2fs_hash_t chash;		\/* hash value of given file name *\/$/;"	m	struct:f2fs_inode_info
check_bg_victims	./gc.c	/^static unsigned int check_bg_victims(struct f2fs_sb_info *sbi)$/;"	f	file:
check_block_count	./segment.h	/^static inline void check_block_count(struct f2fs_sb_info *sbi,$/;"	f
check_direct_IO	./data.c	/^static int check_direct_IO(struct inode *inode, int rw,$/;"	f	file:
check_dnode	./gc.c	/^int check_dnode(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,$/;"	f
check_extent_cache	./data.c	/^static int check_extent_cache(struct inode *inode, pgoff_t pgofs,$/;"	f	file:
check_index_in_prev_nodes	./recovery.c	/^static int check_index_in_prev_nodes(struct f2fs_sb_info *sbi,$/;"	f	file:
check_nid_range	./f2fs.h	/^static inline int check_nid_range(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
check_seg_range	./segment.h	/^static inline void check_seg_range(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f
check_valid_map	./gc.c	/^static int check_valid_map(struct f2fs_sb_info *sbi,$/;"	f	file:
ckpt	./f2fs.h	/^	struct f2fs_checkpoint *ckpt;		\/* raw checkpoint pointer *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_checkpoint
ckpt_valid_blocks	./segment.h	/^	unsigned short ckpt_valid_blocks;$/;"	m	struct:seg_entry
ckpt_valid_map	./segment.h	/^	unsigned char *ckpt_valid_map;$/;"	m	struct:seg_entry
clear_ckpt_flags	./f2fs.h	/^static inline void clear_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)$/;"	f
clear_cold_data	./node.h	/^static inline void clear_cold_data(struct page *page)$/;"	f
clear_file	./node.h	/^static inline void clear_file(struct inode *inode, int type)$/;"	f
clear_inode_flag	./f2fs.h	/^static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)$/;"	f
clear_node_page_dirty	./node.c	/^static void clear_node_page_dirty(struct page *page)$/;"	f	file:
clear_opt	./f2fs.h	52;"	d
clear_prefree_segments	./segment.c	/^void clear_prefree_segments(struct f2fs_sb_info *sbi)$/;"	f
clevel	./f2fs.h	/^	unsigned int clevel;		\/* maximum level of given file name *\/$/;"	m	struct:f2fs_inode_info
cmd_control_info	./f2fs.h	/^	struct flush_cmd_control *cmd_control_info;$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::flush_cmd_control
commit_inmem_pages	./segment.c	/^void commit_inmem_pages(struct inode *inode, bool abort)$/;"	f
cond_clear_inode_flag	./f2fs.h	/^static inline int cond_clear_inode_flag(struct f2fs_inode_info *fi, int flag)$/;"	f
copy_node_footer	./node.h	/^static inline void copy_node_footer(struct page *dst, struct page *src)$/;"	f
count_type	./f2fs.h	/^enum count_type {$/;"	g
cp_control	./f2fs.h	/^struct cp_control {$/;"	s
cp_count	./f2fs.h	/^	int prefree_count, call_count, cp_count;$/;"	m	struct:f2fs_stat_info
cp_mutex	./f2fs.h	/^	struct mutex cp_mutex;			\/* checkpoint procedure lock *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::mutex
cp_rwsem	./f2fs.h	/^	struct rw_semaphore cp_rwsem;		\/* blocking FS operations *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
cp_wait	./f2fs.h	/^	wait_queue_head_t cp_wait;$/;"	m	struct:f2fs_sb_info
cpver_of_node	./node.h	/^static inline unsigned long long cpver_of_node(struct page *node_page)$/;"	f
create_checkpoint_caches	./checkpoint.c	/^int __init create_checkpoint_caches(void)$/;"	f
create_flush_cmd_control	./segment.c	/^int create_flush_cmd_control(struct f2fs_sb_info *sbi)$/;"	f
create_gc_caches	./gc.c	/^int __init create_gc_caches(void)$/;"	f
create_node_manager_caches	./node.c	/^int __init create_node_manager_caches(void)$/;"	f
create_segment_manager_caches	./segment.c	/^int __init create_segment_manager_caches(void)$/;"	f
cur_cp_version	./f2fs.h	/^static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)$/;"	f
cur_valid_map	./segment.h	/^	unsigned char *cur_valid_map;	\/* validity bitmap of blocks *\/$/;"	m	struct:seg_entry
cur_victim_sec	./f2fs.h	/^	unsigned int cur_victim_sec;		\/* current victim section num *\/$/;"	m	struct:f2fs_sb_info
current_nat_addr	./node.h	/^static inline pgoff_t current_nat_addr(struct f2fs_sb_info *sbi, nid_t start)$/;"	f
current_sit_addr	./segment.h	/^static inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,$/;"	f
cursec	./f2fs.h	/^	int cursec[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
curseg	./f2fs.h	/^	int curseg[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
curseg_alloc_type	./segment.h	/^static inline unsigned char curseg_alloc_type(struct f2fs_sb_info *sbi,$/;"	f
curseg_array	./f2fs.h	/^	struct curseg_info *curseg_array;	\/* active segment information *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::curseg_info
curseg_blkoff	./segment.h	/^static inline unsigned short curseg_blkoff(struct f2fs_sb_info *sbi, int type)$/;"	f
curseg_info	./segment.h	/^struct curseg_info {$/;"	s
curseg_mutex	./segment.h	/^	struct mutex curseg_mutex;		\/* lock for consistency *\/$/;"	m	struct:curseg_info	typeref:struct:curseg_info::mutex
curseg_segno	./segment.h	/^static inline unsigned int curseg_segno(struct f2fs_sb_info *sbi,$/;"	f
curzone	./f2fs.h	/^	int curzone[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
data_blkaddr	./f2fs.h	/^	block_t	data_blkaddr;		\/* block address of the node block *\/$/;"	m	struct:dnode_of_data
data_blks	./f2fs.h	/^	int tot_blks, data_blks, node_blks;$/;"	m	struct:f2fs_stat_info
data_segs	./f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
datablock_addr	./f2fs.h	/^static inline block_t datablock_addr(struct page *node_page,$/;"	f
dec_page_count	./f2fs.h	/^static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)$/;"	f
dec_valid_block_count	./f2fs.h	/^static inline void dec_valid_block_count(struct f2fs_sb_info *sbi,$/;"	f
dec_valid_inode_count	./f2fs.h	/^static inline void dec_valid_inode_count(struct f2fs_sb_info *sbi)$/;"	f
dec_valid_node_count	./f2fs.h	/^static inline void dec_valid_node_count(struct f2fs_sb_info *sbi,$/;"	f
decrease_sleep_time	./gc.h	/^static inline long decrease_sleep_time(struct f2fs_gc_kthread *gc_th, long wait)$/;"	f
default_salloc_ops	./segment.c	/^static const struct segment_allocation default_salloc_ops = {$/;"	v	typeref:struct:segment_allocation	file:
default_v_ops	./gc.c	/^static const struct victim_selection default_v_ops = {$/;"	v	typeref:struct:victim_selection	file:
destroy_checkpoint_caches	./checkpoint.c	/^void destroy_checkpoint_caches(void)$/;"	f
destroy_curseg	./segment.c	/^static void destroy_curseg(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_dirty_segmap	./segment.c	/^static void destroy_dirty_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_flush_cmd_control	./segment.c	/^void destroy_flush_cmd_control(struct f2fs_sb_info *sbi)$/;"	f
destroy_free_segmap	./segment.c	/^static void destroy_free_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_fsync_dnodes	./recovery.c	/^static void destroy_fsync_dnodes(struct list_head *head)$/;"	f	file:
destroy_gc_caches	./gc.c	/^void destroy_gc_caches(void)$/;"	f
destroy_inodecache	./super.c	/^static void destroy_inodecache(void)$/;"	f	file:
destroy_node_manager	./node.c	/^void destroy_node_manager(struct f2fs_sb_info *sbi)$/;"	f
destroy_node_manager_caches	./node.c	/^void destroy_node_manager_caches(void)$/;"	f
destroy_segment_manager	./segment.c	/^void destroy_segment_manager(struct f2fs_sb_info *sbi)$/;"	f
destroy_segment_manager_caches	./segment.c	/^void destroy_segment_manager_caches(void)$/;"	f
destroy_sit_info	./segment.c	/^static void destroy_sit_info(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_victim_secmap	./segment.c	/^static void destroy_victim_secmap(struct f2fs_sb_info *sbi)$/;"	f	file:
dir_block_index	./dir.c	/^static unsigned long dir_block_index(unsigned int level,$/;"	f	file:
dir_blocks	./dir.c	/^static unsigned long dir_blocks(struct inode *inode)$/;"	f	file:
dir_buckets	./dir.c	/^static unsigned int dir_buckets(unsigned int level, int dir_level)$/;"	f	file:
dir_inode_entry	./f2fs.h	/^struct dir_inode_entry {$/;"	s
dir_inode_list	./f2fs.h	/^	struct list_head dir_inode_list;	\/* dir inode list *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::list_head
dir_inode_lock	./f2fs.h	/^	spinlock_t dir_inode_lock;		\/* for dir inode list lock *\/$/;"	m	struct:f2fs_sb_info
dir_level	./f2fs.h	/^	int dir_level;				\/* directory level *\/$/;"	m	struct:f2fs_sb_info
dirty_count	./f2fs.h	/^	int dirty_count, node_pages, meta_pages;$/;"	m	struct:f2fs_stat_info
dirty_dir	./f2fs.h	/^	struct dir_inode_entry *dirty_dir;	\/* the pointer of dirty dir *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::dir_inode_entry
dirty_info	./f2fs.h	/^	struct dirty_seglist_info *dirty_info;	\/* dirty segment information *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::dirty_seglist_info
dirty_nat_cnt	./f2fs.h	/^	unsigned int dirty_nat_cnt;	\/* total num of nat entries in set *\/$/;"	m	struct:f2fs_nm_info
dirty_pages	./f2fs.h	/^	atomic_t dirty_pages;		\/* # of dirty pages *\/$/;"	m	struct:f2fs_inode_info
dirty_seglist_info	./segment.h	/^struct dirty_seglist_info {$/;"	s
dirty_segmap	./segment.h	/^	unsigned long *dirty_segmap;	\/* dirty segment bitmap *\/$/;"	m	struct:victim_sel_policy
dirty_segmap	./segment.h	/^	unsigned long *dirty_segmap[NR_DIRTY_TYPE];$/;"	m	struct:dirty_seglist_info
dirty_segments	./segment.h	/^static inline unsigned int dirty_segments(struct f2fs_sb_info *sbi)$/;"	f
dirty_sentries	./segment.h	/^	unsigned int dirty_sentries;		\/* # of dirty sentries *\/$/;"	m	struct:sit_info
dirty_sentries_bitmap	./segment.h	/^	unsigned long *dirty_sentries_bitmap;	\/* bitmap for dirty sentries *\/$/;"	m	struct:sit_info
dirty_type	./segment.h	/^enum dirty_type {$/;"	g
discard_dirty_segmap	./segment.c	/^static void discard_dirty_segmap(struct f2fs_sb_info *sbi,$/;"	f	file:
discard_entry	./f2fs.h	/^struct discard_entry {$/;"	s
discard_entry_slab	./segment.c	/^static struct kmem_cache *discard_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
discard_list	./f2fs.h	/^	struct list_head discard_list;		\/* 4KB discard list *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::list_head
discard_next_dnode	./segment.c	/^void discard_next_dnode(struct f2fs_sb_info *sbi, block_t blkaddr)$/;"	f
dispatch_list	./f2fs.h	/^	struct llist_node *dispatch_list;	\/* list for command dispatch *\/$/;"	m	struct:flush_cmd_control	typeref:struct:flush_cmd_control::llist_node
dnode_of_data	./f2fs.h	/^struct dnode_of_data {$/;"	s
do_checkpoint	./checkpoint.c	/^static void do_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f	file:
do_garbage_collect	./gc.c	/^static void do_garbage_collect(struct f2fs_sb_info *sbi, unsigned int segno,$/;"	f	file:
do_read_inode	./inode.c	/^static int do_read_inode(struct inode *inode)$/;"	f	file:
do_recover_data	./recovery.c	/^static int do_recover_data(struct f2fs_sb_info *sbi, struct inode *inode,$/;"	f	file:
do_write_data_page	./data.c	/^int do_write_data_page(struct page *page, struct f2fs_io_info *fio)$/;"	f
do_write_page	./segment.c	/^static void do_write_page(struct f2fs_sb_info *sbi, struct page *page,$/;"	f	file:
e_id	./acl.h	/^	__le32 e_id;$/;"	m	struct:f2fs_acl_entry
e_name	./xattr.h	/^	char    e_name[0];      \/* attribute name *\/$/;"	m	struct:f2fs_xattr_entry
e_name_index	./xattr.h	/^	__u8    e_name_index;$/;"	m	struct:f2fs_xattr_entry
e_name_len	./xattr.h	/^	__u8    e_name_len;$/;"	m	struct:f2fs_xattr_entry
e_perm	./acl.h	/^	__le16 e_perm;$/;"	m	struct:f2fs_acl_entry
e_perm	./acl.h	/^	__le16 e_perm;$/;"	m	struct:f2fs_acl_entry_short
e_tag	./acl.h	/^	__le16 e_tag;$/;"	m	struct:f2fs_acl_entry
e_tag	./acl.h	/^	__le16 e_tag;$/;"	m	struct:f2fs_acl_entry_short
e_value_size	./xattr.h	/^	__le16  e_value_size;   \/* size of attribute value *\/$/;"	m	struct:f2fs_xattr_entry
early_match_name	./dir.c	/^static bool early_match_name(size_t namelen, f2fs_hash_t namehash,$/;"	f	file:
elapsed_time	./segment.h	/^	unsigned long long elapsed_time;	\/* elapsed time after mount *\/$/;"	m	struct:sit_info
entry_cnt	./node.h	/^	unsigned int entry_cnt;		\/* the # of nat entries in set *\/$/;"	m	struct:nat_entry_set
entry_cnt	./segment.h	/^	unsigned int entry_cnt;		\/* the # of sit entries in set *\/$/;"	m	struct:sit_entry_set
entry_list	./node.h	/^	struct list_head entry_list;	\/* link with dirty nat entries *\/$/;"	m	struct:nat_entry_set	typeref:struct:nat_entry_set::list_head
excess_prefree_segs	./segment.h	/^static inline bool excess_prefree_segs(struct f2fs_sb_info *sbi)$/;"	f
exist_written_data	./checkpoint.c	/^bool exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode)$/;"	f
exit_f2fs_fs	./super.c	/^static void __exit exit_f2fs_fs(void)$/;"	f	file:
expand_inode_data	./file.c	/^static int expand_inode_data(struct inode *inode, loff_t offset,$/;"	f	file:
ext	./f2fs.h	/^	struct extent_info ext;		\/* in-memory extent cache entry *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::extent_info
ext_lock	./f2fs.h	/^	rwlock_t ext_lock;	\/* rwlock for consistency *\/$/;"	m	struct:extent_info
extent_info	./f2fs.h	/^struct extent_info {$/;"	s
f2fs-y	./Makefile	/^f2fs-y		:= dir.o file.o inode.o namei.o hash.o super.o inline.o$/;"	m
f2fs_acl_count	./acl.c	/^static inline int f2fs_acl_count(size_t size)$/;"	f	file:
f2fs_acl_entry	./acl.h	/^struct f2fs_acl_entry {$/;"	s
f2fs_acl_entry_short	./acl.h	/^struct f2fs_acl_entry_short {$/;"	s
f2fs_acl_from_disk	./acl.c	/^static struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)$/;"	f	file:
f2fs_acl_header	./acl.h	/^struct f2fs_acl_header {$/;"	s
f2fs_acl_size	./acl.c	/^static inline size_t f2fs_acl_size(int count)$/;"	f	file:
f2fs_acl_to_disk	./acl.c	/^static void *f2fs_acl_to_disk(const struct posix_acl *acl, size_t *size)$/;"	f	file:
f2fs_add_link	./f2fs.h	/^static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)$/;"	f
f2fs_alloc_inode	./super.c	/^static struct inode *f2fs_alloc_inode(struct super_block *sb)$/;"	f	file:
f2fs_attr	./super.c	/^struct f2fs_attr {$/;"	s	file:
f2fs_attr_ops	./super.c	/^static const struct sysfs_ops f2fs_attr_ops = {$/;"	v	typeref:struct:sysfs_ops	file:
f2fs_attr_show	./super.c	/^static ssize_t f2fs_attr_show(struct kobject *kobj,$/;"	f	file:
f2fs_attr_store	./super.c	/^static ssize_t f2fs_attr_store(struct kobject *kobj, struct attribute *attr,$/;"	f	file:
f2fs_attrs	./super.c	/^static struct attribute *f2fs_attrs[] = {$/;"	v	typeref:struct:attribute	file:
f2fs_balance_fs	./segment.c	/^void f2fs_balance_fs(struct f2fs_sb_info *sbi)$/;"	f
f2fs_balance_fs_bg	./segment.c	/^void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)$/;"	f
f2fs_bio_info	./f2fs.h	/^struct f2fs_bio_info {$/;"	s
f2fs_bitmap_size	./segment.h	101;"	d
f2fs_bmap	./data.c	/^static sector_t f2fs_bmap(struct address_space *mapping, sector_t block)$/;"	f	file:
f2fs_bug_on	./f2fs.h	24;"	d
f2fs_bug_on	./f2fs.h	27;"	d
f2fs_build_stats	./debug.c	/^int f2fs_build_stats(struct f2fs_sb_info *sbi)$/;"	f
f2fs_build_stats	./f2fs.h	/^static inline int f2fs_build_stats(struct f2fs_sb_info *sbi) { return 0; }$/;"	f
f2fs_check_acl	./acl.h	43;"	d
f2fs_clear_bit	./f2fs.h	/^static inline int f2fs_clear_bit(unsigned int nr, char *addr)$/;"	f
f2fs_compat_ioctl	./file.c	/^long f2fs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)$/;"	f
f2fs_convert_inline_data	./inline.c	/^int f2fs_convert_inline_data(struct inode *inode, pgoff_t to_size,$/;"	f
f2fs_cp_error	./f2fs.h	/^static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)$/;"	f
f2fs_crc32	./f2fs.h	/^static inline __u32 f2fs_crc32(void *buf, size_t len)$/;"	f
f2fs_crc_valid	./f2fs.h	/^static inline bool f2fs_crc_valid(__u32 blk_crc, void *buf, size_t buf_size)$/;"	f
f2fs_create	./namei.c	/^static int f2fs_create(struct inode *dir, struct dentry *dentry, umode_t mode,$/;"	f	file:
f2fs_create_root_stats	./debug.c	/^void __init f2fs_create_root_stats(void)$/;"	f
f2fs_create_root_stats	./f2fs.h	/^static inline void __init f2fs_create_root_stats(void) { }$/;"	f
f2fs_cross_rename	./namei.c	/^static int f2fs_cross_rename(struct inode *old_dir, struct dentry *old_dentry,$/;"	f	file:
f2fs_dblock_aops	./data.c	/^const struct address_space_operations f2fs_dblock_aops = {$/;"	v	typeref:struct:address_space_operations
f2fs_debugfs_root	./debug.c	/^static struct dentry *f2fs_debugfs_root;$/;"	v	typeref:struct:dentry	file:
f2fs_delete_entry	./dir.c	/^void f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,$/;"	f
f2fs_dentry_hash	./hash.c	/^f2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)$/;"	f
f2fs_destroy_inode	./super.c	/^static void f2fs_destroy_inode(struct inode *inode)$/;"	f	file:
f2fs_destroy_root_stats	./debug.c	/^void f2fs_destroy_root_stats(void)$/;"	f
f2fs_destroy_root_stats	./f2fs.h	/^static inline void f2fs_destroy_root_stats(void) { }$/;"	f
f2fs_destroy_stats	./debug.c	/^void f2fs_destroy_stats(struct f2fs_sb_info *sbi)$/;"	f
f2fs_destroy_stats	./f2fs.h	/^static inline void f2fs_destroy_stats(struct f2fs_sb_info *sbi) { }$/;"	f
f2fs_dir_inode_operations	./namei.c	/^const struct inode_operations f2fs_dir_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_dir_operations	./dir.c	/^const struct file_operations f2fs_dir_operations = {$/;"	v	typeref:struct:file_operations
f2fs_direct_IO	./data.c	/^static ssize_t f2fs_direct_IO(int rw, struct kiocb *iocb,$/;"	f	file:
f2fs_dirty_inode	./super.c	/^static void f2fs_dirty_inode(struct inode *inode, int flags)$/;"	f	file:
f2fs_do_tmpfile	./dir.c	/^int f2fs_do_tmpfile(struct inode *inode, struct inode *dir)$/;"	f
f2fs_down_write	./f2fs.h	25;"	d
f2fs_down_write	./f2fs.h	34;"	d
f2fs_drop_inode	./super.c	/^static int f2fs_drop_inode(struct inode *inode)$/;"	f	file:
f2fs_empty_dir	./dir.c	/^bool f2fs_empty_dir(struct inode *dir)$/;"	f
f2fs_evict_inode	./inode.c	/^void f2fs_evict_inode(struct inode *inode)$/;"	f
f2fs_export_ops	./super.c	/^static const struct export_operations f2fs_export_ops = {$/;"	v	typeref:struct:export_operations	file:
f2fs_fallocate	./file.c	/^static long f2fs_fallocate(struct file *file, int mode,$/;"	f	file:
f2fs_fh_to_dentry	./super.c	/^static struct dentry *f2fs_fh_to_dentry(struct super_block *sb, struct fid *fid,$/;"	f	file:
f2fs_fh_to_parent	./super.c	/^static struct dentry *f2fs_fh_to_parent(struct super_block *sb, struct fid *fid,$/;"	f	file:
f2fs_fiemap	./data.c	/^int f2fs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,$/;"	f
f2fs_file_inode_operations	./file.c	/^const struct inode_operations f2fs_file_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_file_mmap	./file.c	/^static int f2fs_file_mmap(struct file *file, struct vm_area_struct *vma)$/;"	f	file:
f2fs_file_operations	./file.c	/^const struct file_operations f2fs_file_operations = {$/;"	v	typeref:struct:file_operations
f2fs_file_vm_ops	./file.c	/^static const struct vm_operations_struct f2fs_file_vm_ops = {$/;"	v	typeref:struct:vm_operations_struct	file:
f2fs_filetype_table	./dir.c	/^static unsigned char f2fs_filetype_table[F2FS_FT_MAX] = {$/;"	v	file:
f2fs_fill_super	./super.c	/^static int f2fs_fill_super(struct super_block *sb, void *data, int silent)$/;"	f	file:
f2fs_find_entry	./dir.c	/^struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,$/;"	f
f2fs_freeze	./super.c	/^static int f2fs_freeze(struct super_block *sb)$/;"	f	file:
f2fs_fs_type	./super.c	/^static struct file_system_type f2fs_fs_type = {$/;"	v	typeref:struct:file_system_type	file:
f2fs_gc	./gc.c	/^int f2fs_gc(struct f2fs_sb_info *sbi)$/;"	f
f2fs_gc_kthread	./gc.h	/^struct f2fs_gc_kthread {$/;"	s
f2fs_gc_task	./gc.h	/^	struct task_struct *f2fs_gc_task;$/;"	m	struct:f2fs_gc_kthread	typeref:struct:f2fs_gc_kthread::task_struct
f2fs_get_acl	./acl.c	/^struct posix_acl *f2fs_get_acl(struct inode *inode, int type)$/;"	f
f2fs_get_acl	./acl.h	44;"	d
f2fs_get_parent	./namei.c	/^struct dentry *f2fs_get_parent(struct dentry *child)$/;"	f
f2fs_getattr	./file.c	/^int f2fs_getattr(struct vfsmount *mnt,$/;"	f
f2fs_getxattr	./xattr.c	/^int f2fs_getxattr(struct inode *inode, int index, const char *name,$/;"	f
f2fs_getxattr	./xattr.h	/^static inline int f2fs_getxattr(struct inode *inode, int index,$/;"	f
f2fs_has_inline_data	./f2fs.h	/^static inline int f2fs_has_inline_data(struct inode *inode)$/;"	f
f2fs_has_inline_xattr	./f2fs.h	/^static inline int f2fs_has_inline_xattr(struct inode *inode)$/;"	f
f2fs_has_xattr_block	./f2fs.h	/^static inline bool f2fs_has_xattr_block(unsigned int ofs)$/;"	f
f2fs_i_callback	./super.c	/^static void f2fs_i_callback(struct rcu_head *head)$/;"	f	file:
f2fs_iget	./inode.c	/^struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)$/;"	f
f2fs_init_acl	./acl.c	/^int f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage)$/;"	f
f2fs_init_acl	./acl.h	/^static inline int f2fs_init_acl(struct inode *inode, struct inode *dir,$/;"	f
f2fs_init_security	./xattr.c	/^int f2fs_init_security(struct inode *inode, struct inode *dir,$/;"	f
f2fs_init_security	./xattr.h	/^static inline int f2fs_init_security(struct inode *inode, struct inode *dir,$/;"	f
f2fs_initxattrs	./xattr.c	/^static int f2fs_initxattrs(struct inode *inode, const struct xattr *xattr_array,$/;"	f	file:
f2fs_inode_by_name	./dir.c	/^ino_t f2fs_inode_by_name(struct inode *dir, struct qstr *qstr)$/;"	f
f2fs_inode_cachep	./super.c	/^static struct kmem_cache *f2fs_inode_cachep;$/;"	v	typeref:struct:kmem_cache	file:
f2fs_inode_info	./f2fs.h	/^struct f2fs_inode_info {$/;"	s
f2fs_invalidate_data_page	./data.c	/^static void f2fs_invalidate_data_page(struct page *page, unsigned int offset,$/;"	f	file:
f2fs_invalidate_node_page	./node.c	/^static void f2fs_invalidate_node_page(struct page *page, unsigned int offset,$/;"	f	file:
f2fs_io_info	./f2fs.h	/^struct f2fs_io_info {$/;"	s
f2fs_ioc_commit_atomic_write	./file.c	/^static int f2fs_ioc_commit_atomic_write(struct file *filp)$/;"	f	file:
f2fs_ioc_fitrim	./file.c	/^static int f2fs_ioc_fitrim(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_getflags	./file.c	/^static int f2fs_ioc_getflags(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_setflags	./file.c	/^static int f2fs_ioc_setflags(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_start_atomic_write	./file.c	/^static int f2fs_ioc_start_atomic_write(struct file *filp)$/;"	f	file:
f2fs_ioc_start_volatile_write	./file.c	/^static int f2fs_ioc_start_volatile_write(struct file *filp)$/;"	f	file:
f2fs_ioctl	./file.c	/^long f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)$/;"	f
f2fs_is_atomic_file	./f2fs.h	/^static inline bool f2fs_is_atomic_file(struct inode *inode)$/;"	f
f2fs_is_volatile_file	./f2fs.h	/^static inline bool f2fs_is_volatile_file(struct inode *inode)$/;"	f
f2fs_issue_discard	./segment.c	/^static int f2fs_issue_discard(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_issue_flush	./f2fs.h	/^	struct task_struct *f2fs_issue_flush;	\/* flush thread *\/$/;"	m	struct:flush_cmd_control	typeref:struct:flush_cmd_control::task_struct
f2fs_issue_flush	./segment.c	/^int f2fs_issue_flush(struct f2fs_sb_info *sbi)$/;"	f
f2fs_kmem_cache_alloc	./f2fs.h	/^static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,$/;"	f
f2fs_kmem_cache_create	./f2fs.h	/^static inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,$/;"	f
f2fs_kset	./super.c	/^static struct kset *f2fs_kset;$/;"	v	typeref:struct:kset	file:
f2fs_ktype	./super.c	/^static struct kobj_type f2fs_ktype = {$/;"	v	typeref:struct:kobj_type	file:
f2fs_link	./namei.c	/^static int f2fs_link(struct dentry *old_dentry, struct inode *dir,$/;"	f	file:
f2fs_listxattr	./xattr.c	/^ssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)$/;"	f
f2fs_listxattr	./xattr.h	/^static inline ssize_t f2fs_listxattr(struct dentry *dentry, char *buffer,$/;"	f
f2fs_llseek	./file.c	/^static loff_t f2fs_llseek(struct file *file, loff_t offset, int whence)$/;"	f	file:
f2fs_lock_all	./f2fs.h	/^static inline void f2fs_lock_all(struct f2fs_sb_info *sbi)$/;"	f
f2fs_lock_op	./f2fs.h	/^static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)$/;"	f
f2fs_lookup	./namei.c	/^static struct dentry *f2fs_lookup(struct inode *dir, struct dentry *dentry,$/;"	f	file:
f2fs_mask_flags	./file.c	/^static inline __u32 f2fs_mask_flags(umode_t mode, __u32 flags)$/;"	f	file:
f2fs_may_inline	./inline.c	/^bool f2fs_may_inline(struct inode *inode)$/;"	f
f2fs_meta_aops	./checkpoint.c	/^const struct address_space_operations f2fs_meta_aops = {$/;"	v	typeref:struct:address_space_operations
f2fs_mkdir	./namei.c	/^static int f2fs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)$/;"	f	file:
f2fs_mknod	./namei.c	/^static int f2fs_mknod(struct inode *dir, struct dentry *dentry,$/;"	f	file:
f2fs_mount	./super.c	/^static struct dentry *f2fs_mount(struct file_system_type *fs_type, int flags,$/;"	f	file:
f2fs_mount_info	./f2fs.h	/^struct f2fs_mount_info {$/;"	s
f2fs_msg	./super.c	/^void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)$/;"	f
f2fs_new_inode	./namei.c	/^static struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)$/;"	f	file:
f2fs_nfs_get_inode	./super.c	/^static struct inode *f2fs_nfs_get_inode(struct super_block *sb,$/;"	f	file:
f2fs_nm_info	./f2fs.h	/^struct f2fs_nm_info {$/;"	s
f2fs_node_aops	./node.c	/^const struct address_space_operations f2fs_node_aops = {$/;"	v	typeref:struct:address_space_operations
f2fs_parent_dir	./dir.c	/^struct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)$/;"	f
f2fs_proc_root	./super.c	/^static struct proc_dir_entry *f2fs_proc_root;$/;"	v	typeref:struct:proc_dir_entry	file:
f2fs_put_dnode	./f2fs.h	/^static inline void f2fs_put_dnode(struct dnode_of_data *dn)$/;"	f
f2fs_put_page	./f2fs.h	/^static inline void f2fs_put_page(struct page *page, int unlock)$/;"	f
f2fs_put_super	./super.c	/^static void f2fs_put_super(struct super_block *sb)$/;"	f	file:
f2fs_read_data_page	./data.c	/^static int f2fs_read_data_page(struct file *file, struct page *page)$/;"	f	file:
f2fs_read_data_pages	./data.c	/^static int f2fs_read_data_pages(struct file *file,$/;"	f	file:
f2fs_read_end_io	./data.c	/^static void f2fs_read_end_io(struct bio *bio, int err)$/;"	f	file:
f2fs_read_inline_data	./inline.c	/^int f2fs_read_inline_data(struct inode *inode, struct page *page)$/;"	f
f2fs_readdir	./dir.c	/^static int f2fs_readdir(struct file *file, struct dir_context *ctx)$/;"	f	file:
f2fs_readonly	./f2fs.h	/^static inline int f2fs_readonly(struct super_block *sb)$/;"	f
f2fs_release_data_page	./data.c	/^static int f2fs_release_data_page(struct page *page, gfp_t wait)$/;"	f	file:
f2fs_release_node_page	./node.c	/^static int f2fs_release_node_page(struct page *page, gfp_t wait)$/;"	f	file:
f2fs_remount	./super.c	/^static int f2fs_remount(struct super_block *sb, int *flags, char *data)$/;"	f	file:
f2fs_rename	./namei.c	/^static int f2fs_rename(struct inode *old_dir, struct dentry *old_dentry,$/;"	f	file:
f2fs_rename2	./namei.c	/^static int f2fs_rename2(struct inode *old_dir, struct dentry *old_dentry,$/;"	f	file:
f2fs_reserve_block	./data.c	/^int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)$/;"	f
f2fs_rmdir	./namei.c	/^static int f2fs_rmdir(struct inode *dir, struct dentry *dentry)$/;"	f	file:
f2fs_sb_info	./f2fs.h	/^struct f2fs_sb_info {$/;"	s
f2fs_sb_release	./super.c	/^static void f2fs_sb_release(struct kobject *kobj)$/;"	f	file:
f2fs_sbi_show	./super.c	/^static ssize_t f2fs_sbi_show(struct f2fs_attr *a,$/;"	f	file:
f2fs_sbi_store	./super.c	/^static ssize_t f2fs_sbi_store(struct f2fs_attr *a,$/;"	f	file:
f2fs_seek_block	./file.c	/^static loff_t f2fs_seek_block(struct file *file, loff_t offset, int whence)$/;"	f	file:
f2fs_seq_segment_info_fops	./super.c	/^static const struct file_operations f2fs_seq_segment_info_fops = {$/;"	v	typeref:struct:file_operations	file:
f2fs_set_acl	./acl.c	/^int f2fs_set_acl(struct inode *inode, struct posix_acl *acl, int type)$/;"	f
f2fs_set_acl	./acl.h	45;"	d
f2fs_set_bit	./f2fs.h	/^static inline int f2fs_set_bit(unsigned int nr, char *addr)$/;"	f
f2fs_set_data_page_dirty	./data.c	/^static int f2fs_set_data_page_dirty(struct page *page)$/;"	f	file:
f2fs_set_inode_flags	./inode.c	/^void f2fs_set_inode_flags(struct inode *inode)$/;"	f
f2fs_set_link	./dir.c	/^void f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,$/;"	f
f2fs_set_meta_page_dirty	./checkpoint.c	/^static int f2fs_set_meta_page_dirty(struct page *page)$/;"	f	file:
f2fs_set_node_page_dirty	./node.c	/^static int f2fs_set_node_page_dirty(struct page *page)$/;"	f	file:
f2fs_setattr	./file.c	/^int f2fs_setattr(struct dentry *dentry, struct iattr *attr)$/;"	f
f2fs_setxattr	./xattr.c	/^int f2fs_setxattr(struct inode *inode, int index, const char *name,$/;"	f
f2fs_setxattr	./xattr.h	/^static inline int f2fs_setxattr(struct inode *inode, int index,$/;"	f
f2fs_show_options	./super.c	/^static int f2fs_show_options(struct seq_file *seq, struct dentry *root)$/;"	f	file:
f2fs_sm_info	./f2fs.h	/^struct f2fs_sm_info {$/;"	s
f2fs_sops	./super.c	/^static struct super_operations f2fs_sops = {$/;"	v	typeref:struct:super_operations	file:
f2fs_special_inode_operations	./namei.c	/^const struct inode_operations f2fs_special_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_stat_info	./f2fs.h	/^struct f2fs_stat_info {$/;"	s
f2fs_statfs	./super.c	/^static int f2fs_statfs(struct dentry *dentry, struct kstatfs *buf)$/;"	f	file:
f2fs_stop_checkpoint	./f2fs.h	/^static inline void f2fs_stop_checkpoint(struct f2fs_sb_info *sbi)$/;"	f
f2fs_submit_merged_bio	./data.c	/^void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,$/;"	f
f2fs_submit_page_bio	./data.c	/^int f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,$/;"	f
f2fs_submit_page_mbio	./data.c	/^void f2fs_submit_page_mbio(struct f2fs_sb_info *sbi, struct page *page,$/;"	f
f2fs_symlink	./namei.c	/^static int f2fs_symlink(struct inode *dir, struct dentry *dentry,$/;"	f	file:
f2fs_symlink_inode_operations	./namei.c	/^const struct inode_operations f2fs_symlink_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_sync_file	./file.c	/^int f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)$/;"	f
f2fs_sync_fs	./super.c	/^int f2fs_sync_fs(struct super_block *sb, int sync)$/;"	f
f2fs_test_bit	./f2fs.h	/^static inline int f2fs_test_bit(unsigned int nr, char *addr)$/;"	f
f2fs_tmpfile	./namei.c	/^static int f2fs_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)$/;"	f	file:
f2fs_tokens	./super.c	/^static match_table_t f2fs_tokens = {$/;"	v	file:
f2fs_trim_fs	./segment.c	/^int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)$/;"	f
f2fs_truncate	./file.c	/^void f2fs_truncate(struct inode *inode)$/;"	f
f2fs_type_by_mode	./dir.c	/^static unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {$/;"	v	file:
f2fs_unfreeze	./super.c	/^static int f2fs_unfreeze(struct super_block *sb)$/;"	f	file:
f2fs_unlink	./namei.c	/^static int f2fs_unlink(struct inode *dir, struct dentry *dentry)$/;"	f	file:
f2fs_unlock_all	./f2fs.h	/^static inline void f2fs_unlock_all(struct f2fs_sb_info *sbi)$/;"	f
f2fs_unlock_op	./f2fs.h	/^static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)$/;"	f
f2fs_vm_page_mkwrite	./file.c	/^static int f2fs_vm_page_mkwrite(struct vm_area_struct *vma,$/;"	f	file:
f2fs_wait_on_page_writeback	./segment.c	/^void f2fs_wait_on_page_writeback(struct page *page,$/;"	f
f2fs_write_begin	./data.c	/^static int f2fs_write_begin(struct file *file, struct address_space *mapping,$/;"	f	file:
f2fs_write_data_page	./data.c	/^static int f2fs_write_data_page(struct page *page,$/;"	f	file:
f2fs_write_data_pages	./data.c	/^static int f2fs_write_data_pages(struct address_space *mapping,$/;"	f	file:
f2fs_write_end	./data.c	/^static int f2fs_write_end(struct file *file,$/;"	f	file:
f2fs_write_end_io	./data.c	/^static void f2fs_write_end_io(struct bio *bio, int err)$/;"	f	file:
f2fs_write_failed	./data.c	/^static void f2fs_write_failed(struct address_space *mapping, loff_t to)$/;"	f	file:
f2fs_write_inline_data	./inline.c	/^int f2fs_write_inline_data(struct inode *inode,$/;"	f
f2fs_write_inode	./inode.c	/^int f2fs_write_inode(struct inode *inode, struct writeback_control *wbc)$/;"	f
f2fs_write_meta_page	./checkpoint.c	/^static int f2fs_write_meta_page(struct page *page,$/;"	f	file:
f2fs_write_meta_pages	./checkpoint.c	/^static int f2fs_write_meta_pages(struct address_space *mapping,$/;"	f	file:
f2fs_write_node_page	./node.c	/^static int f2fs_write_node_page(struct page *page,$/;"	f	file:
f2fs_write_node_pages	./node.c	/^static int f2fs_write_node_pages(struct address_space *mapping,$/;"	f	file:
f2fs_xattr_advise_get	./xattr.c	/^static int f2fs_xattr_advise_get(struct dentry *dentry, const char *name,$/;"	f	file:
f2fs_xattr_advise_handler	./xattr.c	/^const struct xattr_handler f2fs_xattr_advise_handler = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_advise_list	./xattr.c	/^static size_t f2fs_xattr_advise_list(struct dentry *dentry, char *list,$/;"	f	file:
f2fs_xattr_advise_set	./xattr.c	/^static int f2fs_xattr_advise_set(struct dentry *dentry, const char *name,$/;"	f	file:
f2fs_xattr_entry	./xattr.h	/^struct f2fs_xattr_entry {$/;"	s
f2fs_xattr_generic_get	./xattr.c	/^static int f2fs_xattr_generic_get(struct dentry *dentry, const char *name,$/;"	f	file:
f2fs_xattr_generic_list	./xattr.c	/^static size_t f2fs_xattr_generic_list(struct dentry *dentry, char *list,$/;"	f	file:
f2fs_xattr_generic_set	./xattr.c	/^static int f2fs_xattr_generic_set(struct dentry *dentry, const char *name,$/;"	f	file:
f2fs_xattr_handler	./xattr.c	/^static inline const struct xattr_handler *f2fs_xattr_handler(int index)$/;"	f	file:
f2fs_xattr_handler_map	./xattr.c	/^static const struct xattr_handler *f2fs_xattr_handler_map[] = {$/;"	v	typeref:struct:xattr_handler	file:
f2fs_xattr_handlers	./xattr.c	/^const struct xattr_handler *f2fs_xattr_handlers[] = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_handlers	./xattr.h	122;"	d
f2fs_xattr_header	./xattr.h	/^struct f2fs_xattr_header {$/;"	s
f2fs_xattr_security_handler	./xattr.c	/^const struct xattr_handler f2fs_xattr_security_handler = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_trusted_handler	./xattr.c	/^const struct xattr_handler f2fs_xattr_trusted_handler = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_user_handler	./xattr.c	/^const struct xattr_handler f2fs_xattr_user_handler = {$/;"	v	typeref:struct:xattr_handler
fcnt	./f2fs.h	/^	unsigned int fcnt;		\/* the number of free node id *\/$/;"	m	struct:f2fs_nm_info
file_clear_cold	./node.h	345;"	d
file_got_pino	./node.h	346;"	d
file_is_cold	./node.h	341;"	d
file_lost_pino	./node.h	344;"	d
file_set_cold	./node.h	343;"	d
file_wrong_pino	./node.h	342;"	d
fill_node_footer	./node.h	/^static inline void fill_node_footer(struct page *page, nid_t nid,$/;"	f
fill_node_footer_blkaddr	./node.h	/^static inline void fill_node_footer_blkaddr(struct page *page, block_t blkaddr)$/;"	f
fill_zero	./file.c	/^static void fill_zero(struct inode *inode, pgoff_t index,$/;"	f	file:
find_data_page	./data.c	/^struct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)$/;"	f
find_fsync_dnodes	./recovery.c	/^static int find_fsync_dnodes(struct f2fs_sb_info *sbi, struct list_head *head)$/;"	f	file:
find_gc_inode	./gc.c	/^static struct inode *find_gc_inode(nid_t ino, struct list_head *ilist)$/;"	f	file:
find_in_block	./dir.c	/^static struct f2fs_dir_entry *find_in_block(struct page *dentry_page,$/;"	f	file:
find_in_level	./dir.c	/^static struct f2fs_dir_entry *find_in_level(struct inode *dir,$/;"	f	file:
find_next_inuse	./segment.h	/^static inline unsigned int find_next_inuse(struct free_segmap_info *free_i,$/;"	f
fio	./f2fs.h	/^	struct f2fs_io_info fio;	\/* store buffered io info. *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::f2fs_io_info
flag	./node.h	/^	unsigned char flag;	\/* for node information bits *\/$/;"	m	struct:nat_entry
flags	./f2fs.h	/^	unsigned long flags;		\/* use to pass per-file flags *\/$/;"	m	struct:f2fs_inode_info
flush_cmd	./f2fs.h	/^struct flush_cmd {$/;"	s
flush_cmd_control	./f2fs.h	/^struct flush_cmd_control {$/;"	s
flush_nat_entries	./node.c	/^void flush_nat_entries(struct f2fs_sb_info *sbi)$/;"	f
flush_sit_entries	./segment.c	/^void flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f
flush_wait_queue	./f2fs.h	/^	wait_queue_head_t flush_wait_queue;	\/* waiting queue for wake-up *\/$/;"	m	struct:flush_cmd_control
fnids	./f2fs.h	/^	int nats, sits, fnids;$/;"	m	struct:f2fs_stat_info
fofs	./f2fs.h	/^	unsigned int fofs;	\/* start offset in a file *\/$/;"	m	struct:extent_info
free_info	./f2fs.h	/^	struct free_segmap_info *free_info;	\/* free segment information *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::free_segmap_info
free_nid	./node.h	/^struct free_nid {$/;"	s
free_nid_list	./f2fs.h	/^	struct list_head free_nid_list;	\/* a list for free nids *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::list_head
free_nid_list_lock	./f2fs.h	/^	spinlock_t free_nid_list_lock;	\/* protect free nid list *\/$/;"	m	struct:f2fs_nm_info
free_nid_root	./f2fs.h	/^	struct radix_tree_root free_nid_root;\/* root of the free_nid cache *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::radix_tree_root
free_nid_slab	./node.c	/^static struct kmem_cache *free_nid_slab;$/;"	v	typeref:struct:kmem_cache	file:
free_secmap	./segment.h	/^	unsigned long *free_secmap;	\/* free section bitmap *\/$/;"	m	struct:free_segmap_info
free_secs	./f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
free_sections	./segment.h	/^	unsigned int free_sections;	\/* # of free sections *\/$/;"	m	struct:free_segmap_info
free_sections	./segment.h	/^static inline unsigned int free_sections(struct f2fs_sb_info *sbi)$/;"	f
free_segmap	./segment.h	/^	unsigned long *free_segmap;	\/* free segment bitmap *\/$/;"	m	struct:free_segmap_info
free_segmap_info	./segment.h	/^struct free_segmap_info {$/;"	s
free_segments	./segment.h	/^	unsigned int free_segments;	\/* # of free segments *\/$/;"	m	struct:free_segmap_info
free_segments	./segment.h	/^static inline unsigned int free_segments(struct f2fs_sb_info *sbi)$/;"	f
free_segs	./f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
free_user_blocks	./gc.h	/^static inline block_t free_user_blocks(struct f2fs_sb_info *sbi)$/;"	f
fsync_entry_slab	./recovery.c	/^static struct kmem_cache *fsync_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
fsync_inode_entry	./f2fs.h	/^struct fsync_inode_entry {$/;"	s
gc_data_segment	./gc.c	/^static void gc_data_segment(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,$/;"	f	file:
gc_idle	./gc.h	/^	unsigned int gc_idle;$/;"	m	struct:f2fs_gc_kthread
gc_mode	./segment.h	/^	int gc_mode;			\/* GC_CB or GC_GREEDY *\/$/;"	m	struct:victim_sel_policy
gc_mutex	./f2fs.h	/^	struct mutex gc_mutex;			\/* mutex for GC *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::mutex
gc_node_segment	./gc.c	/^static void gc_node_segment(struct f2fs_sb_info *sbi,$/;"	f	file:
gc_thread	./f2fs.h	/^	struct f2fs_gc_kthread	*gc_thread;	\/* GC thread *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_gc_kthread
gc_thread_func	./gc.c	/^static int gc_thread_func(void *data)$/;"	f	file:
gc_wait_queue_head	./gc.h	/^	wait_queue_head_t gc_wait_queue_head;$/;"	m	struct:f2fs_gc_kthread
get_blocktype_secs	./f2fs.h	/^static inline int get_blocktype_secs(struct f2fs_sb_info *sbi, int block_type)$/;"	f
get_cb_cost	./gc.c	/^static unsigned int get_cb_cost(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f	file:
get_current_nat_page	./node.c	/^static struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f	file:
get_current_sit_page	./segment.c	/^static struct page *get_current_sit_page(struct f2fs_sb_info *sbi,$/;"	f	file:
get_data_block	./data.c	/^static int get_data_block(struct inode *inode, sector_t iblock,$/;"	f	file:
get_data_block_fiemap	./data.c	/^static int get_data_block_fiemap(struct inode *inode, sector_t iblock,$/;"	f	file:
get_dirty_pages	./f2fs.h	/^static inline int get_dirty_pages(struct inode *inode)$/;"	f
get_dnode_of_data	./node.c	/^int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)$/;"	f
get_extent_info	./f2fs.h	/^static inline void get_extent_info(struct extent_info *ext,$/;"	f
get_fsync_inode	./recovery.c	/^static struct fsync_inode_entry *get_fsync_inode(struct list_head *head,$/;"	f	file:
get_gc_cost	./gc.c	/^static inline unsigned int get_gc_cost(struct f2fs_sb_info *sbi,$/;"	f	file:
get_inline_info	./f2fs.h	/^static inline void get_inline_info(struct f2fs_inode_info *fi,$/;"	f
get_inode_mode	./f2fs.h	1183;"	d
get_lock_data_page	./data.c	/^struct page *get_lock_data_page(struct inode *inode, pgoff_t index)$/;"	f
get_max_cost	./gc.c	/^static unsigned int get_max_cost(struct f2fs_sb_info *sbi,$/;"	f	file:
get_max_meta_blks	./checkpoint.c	/^static inline block_t get_max_meta_blks(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
get_meta_page	./checkpoint.c	/^struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)$/;"	f
get_meta_page_ra	./checkpoint.c	/^struct page *get_meta_page_ra(struct f2fs_sb_info *sbi, pgoff_t index)$/;"	f
get_mtime	./segment.h	/^static inline unsigned long long get_mtime(struct f2fs_sb_info *sbi)$/;"	f
get_nat_bitmap	./node.h	/^static inline void get_nat_bitmap(struct f2fs_sb_info *sbi, void *addr)$/;"	f
get_nat_flag	./node.h	/^static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)$/;"	f
get_new_data_page	./data.c	/^struct page *get_new_data_page(struct inode *inode,$/;"	f
get_new_segment	./segment.c	/^static void get_new_segment(struct f2fs_sb_info *sbi,$/;"	f	file:
get_next_nat_page	./node.c	/^static struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f	file:
get_next_sit_page	./segment.c	/^static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,$/;"	f	file:
get_nid	./node.h	/^static inline nid_t get_nid(struct page *p, int off, bool i)$/;"	f
get_node_info	./node.c	/^void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)$/;"	f
get_node_page	./node.c	/^struct page *get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid)$/;"	f
get_node_page_ra	./node.c	/^struct page *get_node_page_ra(struct page *parent, int start)$/;"	f
get_node_path	./node.c	/^static int get_node_path(struct f2fs_inode_info *fi, long block,$/;"	f	file:
get_pages	./f2fs.h	/^static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)$/;"	f
get_parent_ino	./file.c	/^static int get_parent_ino(struct inode *inode, nid_t *pino)$/;"	f	file:
get_sec_entry	./segment.h	/^static inline struct sec_entry *get_sec_entry(struct f2fs_sb_info *sbi,$/;"	f
get_seg_entry	./segment.h	/^static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,$/;"	f
get_sit_bitmap	./segment.h	/^static inline void get_sit_bitmap(struct f2fs_sb_info *sbi,$/;"	f
get_ssr_segment	./segment.c	/^static int get_ssr_segment(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
get_sum_page	./segment.c	/^struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f
get_valid_blocks	./segment.h	/^static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,$/;"	f
get_valid_checkpoint	./checkpoint.c	/^int get_valid_checkpoint(struct f2fs_sb_info *sbi)$/;"	f
get_victim	./segment.h	/^	int (*get_victim)(struct f2fs_sb_info *, unsigned int *,$/;"	m	struct:victim_selection
get_victim_by_default	./gc.c	/^static int get_victim_by_default(struct f2fs_sb_info *sbi,$/;"	f	file:
grab_meta_page	./checkpoint.c	/^struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)$/;"	f
grab_nat_entry	./node.c	/^static struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)$/;"	f	file:
grab_sit_entry_set	./segment.c	/^static struct sit_entry_set *grab_sit_entry_set(void)$/;"	f	file:
h_magic	./xattr.h	/^	__le32  h_magic;        \/* magic number for identification *\/$/;"	m	struct:f2fs_xattr_header
h_refcount	./xattr.h	/^	__le32  h_refcount;     \/* reference count *\/$/;"	m	struct:f2fs_xattr_header
h_reserved	./xattr.h	/^	__u32   h_reserved[4];  \/* zero right now *\/$/;"	m	struct:f2fs_xattr_header
handle_failed_inode	./inode.c	/^void handle_failed_inode(struct inode *inode)$/;"	f
has_enough_invalid_blocks	./gc.h	/^static inline bool has_enough_invalid_blocks(struct f2fs_sb_info *sbi)$/;"	f
has_fsynced_inode	./node.c	/^bool has_fsynced_inode(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f
has_not_enough_free_secs	./segment.h	/^static inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)$/;"	f
hit_ext	./f2fs.h	/^	int hit_ext, total_ext;$/;"	m	struct:f2fs_stat_info
i_acl_mode	./f2fs.h	/^	umode_t i_acl_mode;		\/* keep file acl mode temporarily *\/$/;"	m	struct:f2fs_inode_info
i_advise	./f2fs.h	/^	unsigned char i_advise;		\/* use to give file attribute hints *\/$/;"	m	struct:f2fs_inode_info
i_current_depth	./f2fs.h	/^	unsigned int i_current_depth;	\/* use only in directory structure *\/$/;"	m	struct:f2fs_inode_info
i_dir_level	./f2fs.h	/^	unsigned char i_dir_level;	\/* use for dentry level for large dir *\/$/;"	m	struct:f2fs_inode_info
i_flags	./f2fs.h	/^	unsigned long i_flags;		\/* keep an inode flags for ioctl *\/$/;"	m	struct:f2fs_inode_info
i_pino	./f2fs.h	/^	unsigned int i_pino;		\/* parent inode number *\/$/;"	m	struct:f2fs_inode_info
i_sem	./f2fs.h	/^	struct rw_semaphore i_sem;	\/* protect fi info *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::rw_semaphore
i_xattr_nid	./f2fs.h	/^	nid_t i_xattr_nid;		\/* node id that contains xattrs *\/$/;"	m	struct:f2fs_inode_info
inc_node_version	./node.h	64;"	d
inc_page_count	./f2fs.h	/^static inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)$/;"	f
inc_valid_block_count	./f2fs.h	/^static inline bool inc_valid_block_count(struct f2fs_sb_info *sbi,$/;"	f
inc_valid_inode_count	./f2fs.h	/^static inline void inc_valid_inode_count(struct f2fs_sb_info *sbi)$/;"	f
inc_valid_node_count	./f2fs.h	/^static inline bool inc_valid_node_count(struct f2fs_sb_info *sbi,$/;"	f
increase_sleep_time	./gc.h	/^static inline long increase_sleep_time(struct f2fs_gc_kthread *gc_th, long wait)$/;"	f
init_dent_inode	./dir.c	/^static void init_dent_inode(const struct qstr *name, struct page *ipage)$/;"	f	file:
init_dirty_segmap	./segment.c	/^static void init_dirty_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
init_f2fs_fs	./super.c	/^static int __init init_f2fs_fs(void)$/;"	f	file:
init_free_segmap	./segment.c	/^static void init_free_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
init_ino_entry_info	./checkpoint.c	/^void init_ino_entry_info(struct f2fs_sb_info *sbi)$/;"	f
init_inode_metadata	./dir.c	/^static struct page *init_inode_metadata(struct inode *inode,$/;"	f	file:
init_inodecache	./super.c	/^static int __init init_inodecache(void)$/;"	f	file:
init_min_max_mtime	./segment.c	/^static void init_min_max_mtime(struct f2fs_sb_info *sbi)$/;"	f	file:
init_node_manager	./node.c	/^static int init_node_manager(struct f2fs_sb_info *sbi)$/;"	f	file:
init_once	./super.c	/^static void init_once(void *foo)$/;"	f	file:
init_sb_info	./super.c	/^static void init_sb_info(struct f2fs_sb_info *sbi)$/;"	f	file:
init_victim_secmap	./segment.c	/^static int init_victim_secmap(struct f2fs_sb_info *sbi)$/;"	f	file:
inline_data_addr	./f2fs.h	/^static inline void *inline_data_addr(struct page *page)$/;"	f
inline_inode	./f2fs.h	/^	int bg_gc, inline_inode;$/;"	m	struct:f2fs_stat_info
inline_inode	./f2fs.h	/^	int inline_inode;			\/* # of inline_data inodes *\/$/;"	m	struct:f2fs_sb_info
inline_xattr_addr	./f2fs.h	/^static inline void *inline_xattr_addr(struct page *page)$/;"	f
inline_xattr_size	./f2fs.h	/^static inline int inline_xattr_size(struct inode *inode)$/;"	f
inmem_entry_slab	./segment.c	/^static struct kmem_cache *inmem_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
inmem_lock	./f2fs.h	/^	struct mutex inmem_lock;	\/* lock for inmemory pages *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::mutex
inmem_pages	./f2fs.h	/^	struct list_head inmem_pages;	\/* inmemory pages managed by f2fs *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::list_head
inmem_pages	./segment.h	/^struct inmem_pages {$/;"	s
ino	./f2fs.h	/^	nid_t ino;		\/* inode number *\/$/;"	m	struct:ino_entry
ino	./node.h	/^	nid_t ino;		\/* inode number of the node's owner *\/$/;"	m	struct:node_info
ino_entry	./f2fs.h	/^struct ino_entry {$/;"	s
ino_entry_slab	./checkpoint.c	/^static struct kmem_cache *ino_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
ino_list	./f2fs.h	/^	struct list_head ino_list[MAX_INO_ENTRY];	\/* inode list head *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::list_head
ino_lock	./f2fs.h	/^	spinlock_t ino_lock[MAX_INO_ENTRY];		\/* for ino entry lock *\/$/;"	m	struct:f2fs_sb_info
ino_of_node	./node.h	/^static inline nid_t ino_of_node(struct page *node_page)$/;"	f
ino_root	./f2fs.h	/^	struct radix_tree_root ino_root[MAX_INO_ENTRY];	\/* ino entry array *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::radix_tree_root
inode	./f2fs.h	/^	struct inode *inode;		\/* vfs inode pointer *\/$/;"	m	struct:dnode_of_data	typeref:struct:dnode_of_data::inode
inode	./f2fs.h	/^	struct inode *inode;	\/* vfs inode pointer *\/$/;"	m	struct:dir_inode_entry	typeref:struct:dir_inode_entry::inode
inode	./f2fs.h	/^	struct inode *inode;	\/* vfs inode pointer *\/$/;"	m	struct:fsync_inode_entry	typeref:struct:fsync_inode_entry::inode
inode	./gc.h	/^	struct inode *inode;$/;"	m	struct:inode_entry	typeref:struct:inode_entry::inode
inode_dec_dirty_pages	./f2fs.h	/^static inline void inode_dec_dirty_pages(struct inode *inode)$/;"	f
inode_entry	./gc.h	/^struct inode_entry {$/;"	s
inode_entry_slab	./checkpoint.c	/^static struct kmem_cache *inode_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
inode_inc_dirty_pages	./f2fs.h	/^static inline void inode_inc_dirty_pages(struct inode *inode)$/;"	f
inode_page	./f2fs.h	/^	struct page *inode_page;	\/* its inode page, NULL is possible *\/$/;"	m	struct:dnode_of_data	typeref:struct:dnode_of_data::page
inode_page_locked	./f2fs.h	/^	bool inode_page_locked;		\/* inode page is locked or not *\/$/;"	m	struct:dnode_of_data
invalidate_blocks	./segment.c	/^void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)$/;"	f
io_rwsem	./f2fs.h	/^	struct rw_semaphore io_rwsem;	\/* blocking op for bio *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::rw_semaphore
ipu_policy	./f2fs.h	/^	unsigned int ipu_policy;	\/* in-place-update policy *\/$/;"	m	struct:f2fs_sm_info
is_checkpointed_node	./node.c	/^bool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
is_cold_data	./node.h	/^static inline int is_cold_data(struct page *page)$/;"	f
is_cold_node	./node.h	369;"	d
is_dent_dnode	./node.h	371;"	d
is_file	./node.h	/^static inline int is_file(struct inode *inode, int type)$/;"	f
is_fsync_dnode	./node.h	370;"	d
is_idle	./gc.h	/^static inline int is_idle(struct f2fs_sb_info *sbi)$/;"	f
is_inode_flag_set	./f2fs.h	/^static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)$/;"	f
is_merged_page	./segment.c	/^static inline bool is_merged_page(struct f2fs_sb_info *sbi,$/;"	f	file:
is_multimedia_file	./namei.c	/^static int is_multimedia_file(const unsigned char *s, const char *sub)$/;"	f	file:
is_next_segment_free	./segment.c	/^static int is_next_segment_free(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
is_node	./node.h	/^static inline int is_node(struct page *page, int type)$/;"	f
is_read_io	./f2fs.h	464;"	d
is_set_ckpt_flags	./f2fs.h	/^static inline bool is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)$/;"	f
issue_flush_thread	./segment.c	/^static int issue_flush_thread(void *data)$/;"	f	file:
issue_list	./f2fs.h	/^	struct llist_head issue_list;		\/* list for command issue *\/$/;"	m	struct:flush_cmd_control	typeref:struct:flush_cmd_control::llist_head
last_block_in_bio	./f2fs.h	/^	sector_t last_block_in_bio;	\/* last block number *\/$/;"	m	struct:f2fs_bio_info
last_dentry	./f2fs.h	/^	block_t last_dentry;	\/* block address locating the last dentry *\/$/;"	m	struct:fsync_inode_entry
last_inode	./f2fs.h	/^	block_t last_inode;	\/* block address locating the last inode *\/$/;"	m	struct:fsync_inode_entry
last_valid_block_count	./f2fs.h	/^	block_t last_valid_block_count;		\/* for recovery *\/$/;"	m	struct:f2fs_sb_info
last_victim	./f2fs.h	/^	unsigned int last_victim[2];		\/* last victim segment # *\/$/;"	m	struct:f2fs_sb_info
len	./f2fs.h	/^	int len;		\/* # of consecutive blocks of the discard *\/$/;"	m	struct:discard_entry
len	./f2fs.h	/^	unsigned int len;	\/* length of the extent *\/$/;"	m	struct:extent_info
limit_free_user_blocks	./gc.h	/^static inline block_t limit_free_user_blocks(struct f2fs_sb_info *sbi)$/;"	f
limit_invalid_user_blocks	./gc.h	/^static inline block_t limit_invalid_user_blocks(struct f2fs_sb_info *sbi)$/;"	f
list	./f2fs.h	/^	struct list_head list;	\/* list head *\/$/;"	m	struct:dir_inode_entry	typeref:struct:dir_inode_entry::list_head
list	./f2fs.h	/^	struct list_head list;	\/* list head *\/$/;"	m	struct:discard_entry	typeref:struct:discard_entry::list_head
list	./f2fs.h	/^	struct list_head list;	\/* list head *\/$/;"	m	struct:fsync_inode_entry	typeref:struct:fsync_inode_entry::list_head
list	./f2fs.h	/^	struct list_head list;	\/* list head *\/$/;"	m	struct:ino_entry	typeref:struct:ino_entry::list_head
list	./gc.h	/^	struct list_head list;$/;"	m	struct:inode_entry	typeref:struct:inode_entry::list_head
list	./node.h	/^	struct list_head list;	\/* for clean or dirty nat list *\/$/;"	m	struct:nat_entry	typeref:struct:nat_entry::list_head
list	./node.h	/^	struct list_head list;	\/* for free node id list *\/$/;"	m	struct:free_nid	typeref:struct:free_nid::list_head
list	./segment.h	/^	struct list_head list;$/;"	m	struct:inmem_pages	typeref:struct:inmem_pages::list_head
list_for_each_xattr	./xattr.h	67;"	d
llnode	./f2fs.h	/^	struct llist_node llnode;$/;"	m	struct:flush_cmd	typeref:struct:flush_cmd::llist_node
locate_dirty_segment	./segment.c	/^static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f	file:
log_blocks_per_seg	./f2fs.h	/^	unsigned int log_blocks_per_seg;	\/* log2 blocks per segment *\/$/;"	m	struct:f2fs_sb_info
log_blocksize	./f2fs.h	/^	unsigned int log_blocksize;		\/* log2 block size *\/$/;"	m	struct:f2fs_sb_info
log_sectors_per_block	./f2fs.h	/^	unsigned int log_sectors_per_block;	\/* log2 sectors per block *\/$/;"	m	struct:f2fs_sb_info
lookup_journal_in_cursum	./segment.c	/^int lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,$/;"	f
main_area_sections	./f2fs.h	/^	int main_area_segs, main_area_sections, main_area_zones;$/;"	m	struct:f2fs_stat_info
main_area_segs	./f2fs.h	/^	int main_area_segs, main_area_sections, main_area_zones;$/;"	m	struct:f2fs_stat_info
main_area_zones	./f2fs.h	/^	int main_area_segs, main_area_sections, main_area_zones;$/;"	m	struct:f2fs_stat_info
main_blkaddr	./f2fs.h	/^	block_t main_blkaddr;		\/* start block address of main area *\/$/;"	m	struct:f2fs_sm_info
main_segments	./f2fs.h	/^	unsigned int main_segments;	\/* # of segments in main area *\/$/;"	m	struct:f2fs_sm_info
make_empty_dir	./dir.c	/^static int make_empty_dir(struct inode *inode,$/;"	f	file:
max_discards	./f2fs.h	/^	int max_discards;			\/* max. discards to be issued *\/$/;"	m	struct:f2fs_sm_info
max_file_size	./super.c	/^static loff_t max_file_size(unsigned bits)$/;"	f	file:
max_hw_blocks	./segment.h	/^static inline unsigned int max_hw_blocks(struct f2fs_sb_info *sbi)$/;"	f
max_mtime	./segment.h	/^	unsigned long long max_mtime;		\/* max. modification time *\/$/;"	m	struct:sit_info
max_nid	./f2fs.h	/^	nid_t max_nid;			\/* maximum possible node ids *\/$/;"	m	struct:f2fs_nm_info
max_orphans	./f2fs.h	/^	unsigned int max_orphans;		\/* max orphan inodes *\/$/;"	m	struct:f2fs_sb_info
max_search	./segment.h	/^	unsigned int max_search;	\/* maximum # of segments to search *\/$/;"	m	struct:victim_sel_policy
max_sleep_time	./gc.h	/^	unsigned int max_sleep_time;$/;"	m	struct:f2fs_gc_kthread
max_victim_search	./f2fs.h	/^	unsigned int max_victim_search;$/;"	m	struct:f2fs_sb_info
mem_type	./node.h	/^enum mem_type {$/;"	g
meta_ino_num	./f2fs.h	/^	unsigned int meta_ino_num;		\/* meta inode number*\/$/;"	m	struct:f2fs_sb_info
meta_inode	./f2fs.h	/^	struct inode *meta_inode;		\/* cache meta blocks *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::inode
meta_pages	./f2fs.h	/^	int dirty_count, node_pages, meta_pages;$/;"	m	struct:f2fs_stat_info
min_cost	./segment.h	/^	unsigned int min_cost;		\/* minimum cost *\/$/;"	m	struct:victim_sel_policy
min_fsync_blocks	./f2fs.h	/^	unsigned int min_fsync_blocks;	\/* threshold for fsync *\/$/;"	m	struct:f2fs_sm_info
min_ipu_util	./f2fs.h	/^	unsigned int min_ipu_util;	\/* in-place-update threshold *\/$/;"	m	struct:f2fs_sm_info
min_mtime	./segment.h	/^	unsigned long long min_mtime;		\/* min. modification time *\/$/;"	m	struct:sit_info
min_segno	./segment.h	/^	unsigned int min_segno;		\/* segment # having min. cost *\/$/;"	m	struct:victim_sel_policy
min_sleep_time	./gc.h	/^	unsigned int min_sleep_time;$/;"	m	struct:f2fs_gc_kthread
mount_opt	./f2fs.h	/^	struct f2fs_mount_info mount_opt;	\/* mount options *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_mount_info
mounted_time	./segment.h	/^	unsigned long long mounted_time;	\/* mount time *\/$/;"	m	struct:sit_info
move_data_page	./gc.c	/^static void move_data_page(struct inode *inode, struct page *page, int gc_type)$/;"	f	file:
mtime	./segment.h	/^	unsigned long long mtime;	\/* modification time of the segment *\/$/;"	m	struct:seg_entry
n_dirty_dirs	./f2fs.h	/^	unsigned int n_dirty_dirs;		\/* # of dir inodes *\/$/;"	m	struct:f2fs_sb_info
n_orphans	./f2fs.h	/^	unsigned int n_orphans;			\/* # of orphan inodes *\/$/;"	m	struct:f2fs_sb_info
nat_area_segs	./f2fs.h	/^	int all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;$/;"	m	struct:f2fs_stat_info
nat_bitmap	./f2fs.h	/^	char *nat_bitmap;		\/* NAT bitmap pointer *\/$/;"	m	struct:f2fs_nm_info
nat_blkaddr	./f2fs.h	/^	block_t nat_blkaddr;		\/* base disk address of NAT *\/$/;"	m	struct:f2fs_nm_info
nat_cnt	./f2fs.h	/^	unsigned int nat_cnt;		\/* the # of cached nat entries *\/$/;"	m	struct:f2fs_nm_info
nat_entries	./f2fs.h	/^	struct list_head nat_entries;	\/* cached nat entry list (clean) *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::list_head
nat_entry	./node.h	/^struct nat_entry {$/;"	s
nat_entry_set	./node.h	/^struct nat_entry_set {$/;"	s
nat_entry_set_slab	./node.c	/^static struct kmem_cache *nat_entry_set_slab;$/;"	v	typeref:struct:kmem_cache	file:
nat_entry_slab	./node.c	/^static struct kmem_cache *nat_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
nat_get_blkaddr	./node.h	57;"	d
nat_get_ino	./node.h	59;"	d
nat_get_nid	./node.h	55;"	d
nat_get_version	./node.h	61;"	d
nat_in_journal	./f2fs.h	162;"	d
nat_reset_flag	./node.h	/^static inline void nat_reset_flag(struct nat_entry *ne)$/;"	f
nat_root	./f2fs.h	/^	struct radix_tree_root nat_root;\/* root of the nat entry cache *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::radix_tree_root
nat_set_blkaddr	./node.h	58;"	d
nat_set_ino	./node.h	60;"	d
nat_set_nid	./node.h	56;"	d
nat_set_root	./f2fs.h	/^	struct radix_tree_root nat_set_root;\/* root of the nat set cache *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::radix_tree_root
nat_set_version	./node.h	62;"	d
nat_tree_lock	./f2fs.h	/^	rwlock_t nat_tree_lock;		\/* protect nat_tree_lock *\/$/;"	m	struct:f2fs_nm_info
nats	./f2fs.h	/^	int nats, sits, fnids;$/;"	m	struct:f2fs_stat_info
nats_in_cursum	./f2fs.h	159;"	d
ndirty_dent	./f2fs.h	/^	int ndirty_node, ndirty_dent, ndirty_dirs, ndirty_meta;$/;"	m	struct:f2fs_stat_info
ndirty_dirs	./f2fs.h	/^	int ndirty_node, ndirty_dent, ndirty_dirs, ndirty_meta;$/;"	m	struct:f2fs_stat_info
ndirty_meta	./f2fs.h	/^	int ndirty_node, ndirty_dent, ndirty_dirs, ndirty_meta;$/;"	m	struct:f2fs_stat_info
ndirty_node	./f2fs.h	/^	int ndirty_node, ndirty_dent, ndirty_dirs, ndirty_meta;$/;"	m	struct:f2fs_stat_info
need_SSR	./segment.h	/^static inline bool need_SSR(struct f2fs_sb_info *sbi)$/;"	f
need_do_checkpoint	./file.c	/^static inline bool need_do_checkpoint(struct inode *inode)$/;"	f	file:
need_dummy_page_write	./segment.c	/^static inline bool need_dummy_page_write(struct f2fs_sb_info *sbi, struct f2fs_io_info *fio,$/;"	f	file:
need_fsck	./f2fs.h	/^	bool need_fsck;				\/* need fsck.f2fs to fix *\/$/;"	m	struct:f2fs_sb_info
need_inode_block_update	./node.c	/^bool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f
need_inplace_update	./segment.h	/^static inline bool need_inplace_update(struct inode *inode)$/;"	f
need_prev_page_rewrite	./segment.c	/^static inline bool need_prev_page_rewrite(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
new_curseg	./segment.c	/^static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)$/;"	f	file:
new_inode_page	./node.c	/^struct page *new_inode_page(struct inode *inode)$/;"	f
new_node_page	./node.c	/^struct page *new_node_page(struct dnode_of_data *dn,$/;"	f
next_blkaddr_of_node	./node.h	/^static inline block_t next_blkaddr_of_node(struct page *node_page)$/;"	f
next_blkoff	./segment.h	/^	unsigned short next_blkoff;		\/* next block offset to write *\/$/;"	m	struct:curseg_info
next_free_nid	./node.h	/^static inline void next_free_nid(struct f2fs_sb_info *sbi, nid_t *nid)$/;"	f
next_nat_addr	./node.h	/^static inline pgoff_t next_nat_addr(struct f2fs_sb_info *sbi,$/;"	f
next_scan_nid	./f2fs.h	/^	nid_t next_scan_nid;		\/* the next nid to be scanned *\/$/;"	m	struct:f2fs_nm_info
next_segno	./segment.h	/^	unsigned int next_segno;		\/* preallocated segment *\/$/;"	m	struct:curseg_info
next_sit_addr	./segment.h	/^static inline pgoff_t next_sit_addr(struct f2fs_sb_info *sbi,$/;"	f
ni	./node.h	/^	struct node_info ni;	\/* in-memory node information *\/$/;"	m	struct:nat_entry	typeref:struct:nat_entry::node_info
nid	./f2fs.h	/^	nid_t nid;			\/* node id of the direct node block *\/$/;"	m	struct:dnode_of_data
nid	./node.h	/^	nid_t nid;		\/* node id *\/$/;"	m	struct:free_nid
nid	./node.h	/^	nid_t nid;		\/* node id *\/$/;"	m	struct:node_info
nid_in_journal	./f2fs.h	163;"	d
nid_of_node	./node.h	/^static inline nid_t nid_of_node(struct page *node_page)$/;"	f
nid_state	./node.h	/^enum nid_state {$/;"	g
nid_t	./f2fs.h	/^typedef u32 nid_t;$/;"	t
nm_info	./f2fs.h	/^	struct f2fs_nm_info *nm_info;		\/* node manager *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_nm_info
no_gc_sleep_time	./gc.h	/^	unsigned int no_gc_sleep_time;$/;"	m	struct:f2fs_gc_kthread
node_blks	./f2fs.h	/^	int tot_blks, data_blks, node_blks;$/;"	m	struct:f2fs_stat_info
node_info	./node.h	/^struct node_info {$/;"	s
node_info_from_raw_nat	./node.h	/^static inline void node_info_from_raw_nat(struct node_info *ni,$/;"	f
node_ino_num	./f2fs.h	/^	unsigned int node_ino_num;		\/* node inode number*\/$/;"	m	struct:f2fs_sb_info
node_inode	./f2fs.h	/^	struct inode *node_inode;		\/* cache node blocks *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::inode
node_page	./f2fs.h	/^	struct page *node_page;		\/* cached direct node page *\/$/;"	m	struct:dnode_of_data	typeref:struct:dnode_of_data::page
node_pages	./f2fs.h	/^	int dirty_count, node_pages, meta_pages;$/;"	m	struct:f2fs_stat_info
node_segs	./f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
node_write	./f2fs.h	/^	struct rw_semaphore node_write;		\/* locking node writes *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
npages_for_summary_flush	./segment.c	/^int npages_for_summary_flush(struct f2fs_sb_info *sbi)$/;"	f
nr_dirty	./segment.h	/^	int nr_dirty[NR_DIRTY_TYPE];		\/* # of dirty segments *\/$/;"	m	struct:dirty_seglist_info
nr_discards	./f2fs.h	/^	int nr_discards;			\/* # of discards in the list *\/$/;"	m	struct:f2fs_sm_info
nr_pages	./f2fs.h	/^	atomic_t nr_pages[NR_COUNT_TYPE];	\/* # of pages, see count_type *\/$/;"	m	struct:f2fs_sb_info
nr_pages_to_skip	./segment.h	/^static inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)$/;"	f
nr_pages_to_write	./segment.h	/^static inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,$/;"	f
offset	./segment.h	/^	unsigned int offset;		\/* last scanned bitmap offset *\/$/;"	m	struct:victim_sel_policy
offset	./super.c	/^	int offset;$/;"	m	struct:f2fs_attr	file:
ofs_in_node	./f2fs.h	/^	unsigned int ofs_in_node;	\/* data offset in the node page *\/$/;"	m	struct:dnode_of_data
ofs_of_node	./node.h	/^static inline unsigned int ofs_of_node(struct page *node_page)$/;"	f
ofs_unit	./segment.h	/^	unsigned int ofs_unit;		\/* bitmap search unit *\/$/;"	m	struct:victim_sel_policy
on_build_free_nids	./node.c	24;"	d	file:
opt	./f2fs.h	/^	unsigned int	opt;$/;"	m	struct:f2fs_mount_info
overp_segs	./f2fs.h	/^	int rsvd_segs, overp_segs;$/;"	m	struct:f2fs_stat_info
overprovision_sections	./segment.h	/^static inline int overprovision_sections(struct f2fs_sb_info *sbi)$/;"	f
overprovision_segments	./segment.h	/^static inline int overprovision_segments(struct f2fs_sb_info *sbi)$/;"	f
ovp_segments	./f2fs.h	/^	unsigned int ovp_segments;	\/* # of overprovision segments *\/$/;"	m	struct:f2fs_sm_info
page	./segment.h	/^	struct page *page;$/;"	m	struct:inmem_pages	typeref:struct:inmem_pages::page
page_type	./f2fs.h	/^enum page_type {$/;"	g
parse_options	./super.c	/^static int parse_options(struct super_block *sb, char *options)$/;"	f	file:
por_doing	./f2fs.h	/^	bool por_doing;				\/* recovery is doing or not *\/$/;"	m	struct:f2fs_sb_info
prefree_count	./f2fs.h	/^	int prefree_count, call_count, cp_count;$/;"	m	struct:f2fs_stat_info
prefree_segments	./segment.h	/^static inline unsigned int prefree_segments(struct f2fs_sb_info *sbi)$/;"	f
punch_hole	./file.c	/^static int punch_hole(struct inode *inode, loff_t offset, loff_t len)$/;"	f	file:
put_gc_inode	./gc.c	/^static void put_gc_inode(struct list_head *ilist)$/;"	f	file:
ra_meta_pages	./checkpoint.c	/^int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)$/;"	f
ra_node_page	./node.c	/^void ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
ra_sum_pages	./node.c	/^static int ra_sum_pages(struct f2fs_sb_info *sbi, struct page **pages,$/;"	f	file:
ram_thresh	./f2fs.h	/^	unsigned int ram_thresh;	\/* control the memory footprint *\/$/;"	m	struct:f2fs_nm_info
raw_nat_from_node_info	./node.h	/^static inline void raw_nat_from_node_info(struct f2fs_nat_entry *raw_ne,$/;"	f
raw_super	./f2fs.h	/^	struct f2fs_super_block *raw_super;	\/* raw super block pointer *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_super_block
raw_super_buf	./f2fs.h	/^	struct buffer_head *raw_super_buf;	\/* buffer head of raw sb *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::buffer_head
read_all_xattrs	./xattr.c	/^static void *read_all_xattrs(struct inode *inode, struct page *ipage)$/;"	f	file:
read_and_submit_prev_page	./segment.c	/^static inline void read_and_submit_prev_page(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
read_compacted_summaries	./segment.c	/^static int read_compacted_summaries(struct f2fs_sb_info *sbi)$/;"	f	file:
read_hit_ext	./f2fs.h	/^	int total_hit_ext, read_hit_ext;	\/* extent cache hit ratio *\/$/;"	m	struct:f2fs_sb_info
read_io	./f2fs.h	/^	struct f2fs_bio_info read_io;			\/* for read bios *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_bio_info
read_node_page	./node.c	/^static int read_node_page(struct page *page, int rw)$/;"	f	file:
read_normal_summaries	./segment.c	/^static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
read_raw_super_block	./super.c	/^static int read_raw_super_block(struct super_block *sb,$/;"	f	file:
reason	./f2fs.h	/^	int reason;$/;"	m	struct:cp_control
rec_prefree_segments	./f2fs.h	/^	unsigned int rec_prefree_segments;$/;"	m	struct:f2fs_sm_info
recover_data	./recovery.c	/^static int recover_data(struct f2fs_sb_info *sbi,$/;"	f	file:
recover_data_page	./segment.c	/^void recover_data_page(struct f2fs_sb_info *sbi,$/;"	f
recover_dentry	./recovery.c	/^static int recover_dentry(struct inode *inode, struct page *ipage)$/;"	f	file:
recover_fsync_data	./recovery.c	/^int recover_fsync_data(struct f2fs_sb_info *sbi)$/;"	f
recover_inline_data	./inline.c	/^bool recover_inline_data(struct inode *inode, struct page *npage)$/;"	f
recover_inline_xattr	./node.c	/^void recover_inline_xattr(struct inode *inode, struct page *page)$/;"	f
recover_inode	./recovery.c	/^static void recover_inode(struct inode *inode, struct page *page)$/;"	f	file:
recover_inode_page	./node.c	/^int recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)$/;"	f
recover_orphan_inode	./checkpoint.c	/^static void recover_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f	file:
recover_orphan_inodes	./checkpoint.c	/^void recover_orphan_inodes(struct f2fs_sb_info *sbi)$/;"	f
recover_xattr_data	./node.c	/^void recover_xattr_data(struct inode *inode, struct page *page, block_t blkaddr)$/;"	f
refresh_sit_entry	./segment.c	/^void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)$/;"	f
register_inmem_page	./segment.c	/^void register_inmem_page(struct inode *inode, struct page *page)$/;"	f
release_dirty_inode	./checkpoint.c	/^void release_dirty_inode(struct f2fs_sb_info *sbi)$/;"	f
release_discard_addrs	./segment.c	/^void release_discard_addrs(struct f2fs_sb_info *sbi)$/;"	f
release_orphan_inode	./checkpoint.c	/^void release_orphan_inode(struct f2fs_sb_info *sbi)$/;"	f
release_sit_entry_set	./segment.c	/^static void release_sit_entry_set(struct sit_entry_set *ses)$/;"	f	file:
remove_dirty_dir_inode	./checkpoint.c	/^void remove_dirty_dir_inode(struct inode *inode)$/;"	f
remove_dirty_inode	./checkpoint.c	/^void remove_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)$/;"	f
remove_free_nid	./node.c	/^static void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)$/;"	f	file:
remove_inode_page	./node.c	/^void remove_inode_page(struct inode *inode)$/;"	f
remove_nats_in_journal	./node.c	/^static void remove_nats_in_journal(struct f2fs_sb_info *sbi)$/;"	f	file:
remove_orphan_inode	./checkpoint.c	/^void remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f
remove_sits_in_journal	./segment.c	/^static void remove_sits_in_journal(struct f2fs_sb_info *sbi)$/;"	f	file:
reserve_new_block	./data.c	/^int reserve_new_block(struct dnode_of_data *dn)$/;"	f
reserved_sections	./segment.h	/^static inline int reserved_sections(struct f2fs_sb_info *sbi)$/;"	f
reserved_segments	./f2fs.h	/^	unsigned int reserved_segments;	\/* # of reserved segments *\/$/;"	m	struct:f2fs_sm_info
reserved_segments	./segment.h	/^static inline int reserved_segments(struct f2fs_sb_info *sbi)$/;"	f
reset_curseg	./segment.c	/^static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)$/;"	f	file:
restore_curseg_summaries	./segment.c	/^static int restore_curseg_summaries(struct f2fs_sb_info *sbi)$/;"	f	file:
restore_node_summary	./node.c	/^int restore_node_summary(struct f2fs_sb_info *sbi,$/;"	f
ret	./f2fs.h	/^	int ret;$/;"	m	struct:flush_cmd
rewrite_data_page	./segment.c	/^void rewrite_data_page(struct page *page, block_t old_blkaddr,$/;"	f
room_for_filename	./dir.c	/^static int room_for_filename(struct f2fs_dentry_block *dentry_blk, int slots)$/;"	f	file:
root_ino_num	./f2fs.h	/^	unsigned int root_ino_num;		\/* root inode number*\/$/;"	m	struct:f2fs_sb_info
rsvd_segs	./f2fs.h	/^	int rsvd_segs, overp_segs;$/;"	m	struct:f2fs_stat_info
rw	./f2fs.h	/^	int rw;			\/* contains R\/RS\/W\/WS with REQ_META\/REQ_PRIO *\/$/;"	m	struct:f2fs_io_info
s_dirty	./f2fs.h	/^	int s_dirty;				\/* dirty flag for checkpoint *\/$/;"	m	struct:f2fs_sb_info
s_kobj	./f2fs.h	/^	struct kobject s_kobj;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::kobject
s_kobj_unregister	./f2fs.h	/^	struct completion s_kobj_unregister;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::completion
s_next_generation	./f2fs.h	/^	u32 s_next_generation;			\/* for NFS support *\/$/;"	m	struct:f2fs_sb_info
s_ops	./segment.h	/^	const struct segment_allocation *s_ops;$/;"	m	struct:sit_info	typeref:struct:sit_info::segment_allocation
s_proc	./f2fs.h	/^	struct proc_dir_entry *s_proc;		\/* proc entry *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::proc_dir_entry
sanity_check_ckpt	./super.c	/^static int sanity_check_ckpt(struct f2fs_sb_info *sbi)$/;"	f	file:
sanity_check_raw_super	./super.c	/^static int sanity_check_raw_super(struct super_block *sb,$/;"	f	file:
sb	./f2fs.h	/^	struct super_block *sb;			\/* pointer to VFS super block *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::super_block
sbi	./f2fs.h	/^	struct f2fs_sb_info *sbi;	\/* f2fs superblock *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::f2fs_sb_info
sbi	./f2fs.h	/^	struct f2fs_sb_info *sbi;$/;"	m	struct:f2fs_stat_info	typeref:struct:f2fs_stat_info::f2fs_sb_info
scan_nat_page	./node.c	/^static void scan_nat_page(struct f2fs_sb_info *sbi,$/;"	f	file:
sec_entries	./segment.h	/^	struct sec_entry *sec_entries;		\/* SIT section-level cache *\/$/;"	m	struct:sit_info	typeref:struct:sit_info::sec_entry
sec_entry	./segment.h	/^struct sec_entry {$/;"	s
sec_usage_check	./segment.h	/^static inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)$/;"	f
secs_per_zone	./f2fs.h	/^	unsigned int secs_per_zone;		\/* sections per zone *\/$/;"	m	struct:f2fs_sb_info
seg0_blkaddr	./f2fs.h	/^	block_t seg0_blkaddr;		\/* block address of 0'th segment *\/$/;"	m	struct:f2fs_sm_info
seg_entry	./segment.h	/^struct seg_entry {$/;"	s
seg_info_from_raw_sit	./segment.h	/^static inline void seg_info_from_raw_sit(struct seg_entry *se,$/;"	f
seg_info_to_raw_sit	./segment.h	/^static inline void seg_info_to_raw_sit(struct seg_entry *se,$/;"	f
seglist_lock	./segment.h	/^	struct mutex seglist_lock;		\/* lock for segment bitmaps *\/$/;"	m	struct:dirty_seglist_info	typeref:struct:dirty_seglist_info::mutex
segmap_lock	./segment.h	/^	rwlock_t segmap_lock;		\/* free segmap lock *\/$/;"	m	struct:free_segmap_info
segment_allocation	./segment.h	/^struct segment_allocation {$/;"	s
segment_count	./f2fs.h	/^	unsigned int segment_count;	\/* total # of segments *\/$/;"	m	struct:f2fs_sm_info
segment_count	./f2fs.h	/^	unsigned int segment_count[2];		\/* # of allocated segments *\/$/;"	m	struct:f2fs_sb_info
segment_count	./f2fs.h	/^	unsigned int segment_count[2];$/;"	m	struct:f2fs_stat_info
segment_info_open_fs	./super.c	/^static int segment_info_open_fs(struct inode *inode, struct file *file)$/;"	f	file:
segment_info_seq_show	./super.c	/^static int segment_info_seq_show(struct seq_file *seq, void *offset)$/;"	f	file:
segno	./segment.h	/^	unsigned int segno;			\/* current segment number *\/$/;"	m	struct:curseg_info
segno_in_journal	./f2fs.h	165;"	d
segs_per_sec	./f2fs.h	/^	unsigned int segs_per_sec;		\/* segments per section *\/$/;"	m	struct:f2fs_sb_info
select_gc_type	./gc.c	/^static int select_gc_type(struct f2fs_gc_kthread *gc_th, int gc_type)$/;"	f	file:
select_policy	./gc.c	/^static void select_policy(struct f2fs_sb_info *sbi, int gc_type,$/;"	f	file:
sentries	./segment.h	/^	struct seg_entry *sentries;		\/* SIT segment-level cache *\/$/;"	m	struct:sit_info	typeref:struct:sit_info::seg_entry
sentry_lock	./segment.h	/^	struct mutex sentry_lock;		\/* to protect SIT cache *\/$/;"	m	struct:sit_info	typeref:struct:sit_info::mutex
sents_per_block	./segment.h	/^	unsigned int sents_per_block;		\/* # of SIT entries per block *\/$/;"	m	struct:sit_info
set	./node.h	/^	nid_t set;			\/* set number*\/$/;"	m	struct:nat_entry_set
set_acl_inode	./f2fs.h	/^static inline void set_acl_inode(struct f2fs_inode_info *fi, umode_t mode)$/;"	f
set_ckpt_flags	./f2fs.h	/^static inline void set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)$/;"	f
set_cold_data	./node.h	/^static inline void set_cold_data(struct page *page)$/;"	f
set_cold_files	./namei.c	/^static inline void set_cold_files(struct f2fs_sb_info *sbi, struct inode *inode,$/;"	f	file:
set_cold_node	./node.h	/^static inline void set_cold_node(struct inode *inode, struct page *page)$/;"	f
set_de_type	./dir.c	/^static void set_de_type(struct f2fs_dir_entry *de, struct inode *inode)$/;"	f	file:
set_dentry_mark	./node.h	395;"	d
set_file	./node.h	/^static inline void set_file(struct inode *inode, int type)$/;"	f
set_fsync_mark	./node.h	396;"	d
set_inode_flag	./f2fs.h	/^static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)$/;"	f
set_list	./node.h	/^	struct list_head set_list;	\/* link with other nat sets *\/$/;"	m	struct:nat_entry_set	typeref:struct:nat_entry_set::list_head
set_list	./segment.h	/^	struct list_head set_list;	\/* link with all sit sets *\/$/;"	m	struct:sit_entry_set	typeref:struct:sit_entry_set::list_head
set_mark	./node.h	/^static inline void set_mark(struct page *page, int mark, int type)$/;"	f
set_nat_flag	./node.h	/^static inline void set_nat_flag(struct nat_entry *ne,$/;"	f
set_new_dnode	./f2fs.h	/^static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,$/;"	f
set_nid	./node.h	/^static inline void set_nid(struct page *p, int off, nid_t nid, bool i)$/;"	f
set_node_addr	./node.c	/^static void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,$/;"	f	file:
set_opt	./f2fs.h	53;"	d
set_prefree_as_free_segments	./segment.c	/^static void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)$/;"	f	file:
set_raw_extent	./f2fs.h	/^static inline void set_raw_extent(struct extent_info *ext,$/;"	f
set_raw_inline	./f2fs.h	/^static inline void set_raw_inline(struct f2fs_inode_info *fi,$/;"	f
set_summary	./segment.h	/^static inline void set_summary(struct f2fs_summary *sum, nid_t nid,$/;"	f
set_to_next_nat	./node.h	/^static inline void set_to_next_nat(struct f2fs_nm_info *nm_i, nid_t start_nid)$/;"	f
set_to_next_sit	./segment.h	/^static inline void set_to_next_sit(struct sit_info *sit_i, unsigned int start)$/;"	f
show	./super.c	/^	ssize_t (*show)(struct f2fs_attr *, struct f2fs_sb_info *, char *);$/;"	m	struct:f2fs_attr	file:
sit_area_segs	./f2fs.h	/^	int all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;$/;"	m	struct:f2fs_stat_info
sit_base_addr	./segment.h	/^	block_t sit_base_addr;		\/* start block address of SIT area *\/$/;"	m	struct:sit_info
sit_bitmap	./segment.h	/^	char *sit_bitmap;		\/* SIT bitmap pointer *\/$/;"	m	struct:sit_info
sit_blocks	./segment.h	/^	block_t sit_blocks;		\/* # of blocks used by SIT area *\/$/;"	m	struct:sit_info
sit_entry_set	./f2fs.h	/^	struct list_head sit_entry_set;	\/* sit entry set list *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::list_head
sit_entry_set	./segment.h	/^struct sit_entry_set {$/;"	s
sit_entry_set_slab	./segment.c	/^static struct kmem_cache *sit_entry_set_slab;$/;"	v	typeref:struct:kmem_cache	file:
sit_in_journal	./f2fs.h	164;"	d
sit_info	./f2fs.h	/^	struct sit_info *sit_info;		\/* whole segment information *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::sit_info
sit_info	./segment.h	/^struct sit_info {$/;"	s
sits	./f2fs.h	/^	int nats, sits, fnids;$/;"	m	struct:f2fs_stat_info
sits_in_cursum	./f2fs.h	160;"	d
sm_info	./f2fs.h	/^	struct f2fs_sm_info *sm_info;		\/* segment manager *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_sm_info
space_for_roll_forward	./recovery.c	/^bool space_for_roll_forward(struct f2fs_sb_info *sbi)$/;"	f
ssa_area_segs	./f2fs.h	/^	int all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;$/;"	m	struct:f2fs_stat_info
ssa_blkaddr	./f2fs.h	/^	block_t ssa_blkaddr;		\/* start block address of SSA area *\/$/;"	m	struct:f2fs_sm_info
start_bidx_of_node	./gc.c	/^block_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)$/;"	f
start_gc_thread	./gc.c	/^int start_gc_thread(struct f2fs_sb_info *sbi)$/;"	f
start_segno	./segment.h	/^	unsigned int start_segno;	\/* start segment number logically *\/$/;"	m	struct:free_segmap_info
start_segno	./segment.h	/^	unsigned int start_segno;	\/* start segno of sits in set *\/$/;"	m	struct:sit_entry_set
start_sum_block	./segment.h	/^static inline block_t start_sum_block(struct f2fs_sb_info *sbi)$/;"	f
stat_dec_dirty_dir	./f2fs.h	1435;"	d
stat_dec_dirty_dir	./f2fs.h	1490;"	d
stat_dec_inline_inode	./f2fs.h	1443;"	d
stat_dec_inline_inode	./f2fs.h	1494;"	d
stat_fops	./debug.c	/^static const struct file_operations stat_fops = {$/;"	v	typeref:struct:file_operations	file:
stat_inc_bggc_count	./f2fs.h	1433;"	d
stat_inc_bggc_count	./f2fs.h	1488;"	d
stat_inc_block_count	./f2fs.h	1451;"	d
stat_inc_block_count	./f2fs.h	1496;"	d
stat_inc_call_count	./f2fs.h	1432;"	d
stat_inc_call_count	./f2fs.h	1487;"	d
stat_inc_cp_count	./f2fs.h	1431;"	d
stat_inc_cp_count	./f2fs.h	1486;"	d
stat_inc_data_blk_count	./f2fs.h	1467;"	d
stat_inc_data_blk_count	./f2fs.h	1499;"	d
stat_inc_dirty_dir	./f2fs.h	1434;"	d
stat_inc_dirty_dir	./f2fs.h	1489;"	d
stat_inc_inline_inode	./f2fs.h	1438;"	d
stat_inc_inline_inode	./f2fs.h	1493;"	d
stat_inc_node_blk_count	./f2fs.h	1474;"	d
stat_inc_node_blk_count	./f2fs.h	1500;"	d
stat_inc_read_hit	./f2fs.h	1437;"	d
stat_inc_read_hit	./f2fs.h	1492;"	d
stat_inc_seg_count	./f2fs.h	1454;"	d
stat_inc_seg_count	./f2fs.h	1497;"	d
stat_inc_seg_type	./f2fs.h	1449;"	d
stat_inc_seg_type	./f2fs.h	1495;"	d
stat_inc_tot_blk_count	./f2fs.h	1464;"	d
stat_inc_tot_blk_count	./f2fs.h	1498;"	d
stat_inc_total_hit	./f2fs.h	1436;"	d
stat_inc_total_hit	./f2fs.h	1491;"	d
stat_info	./f2fs.h	/^	struct f2fs_stat_info *stat_info;	\/* FS status information *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_stat_info
stat_list	./f2fs.h	/^	struct list_head stat_list;$/;"	m	struct:f2fs_stat_info	typeref:struct:f2fs_stat_info::list_head
stat_lock	./f2fs.h	/^	spinlock_t stat_lock;			\/* lock for stat operations *\/$/;"	m	struct:f2fs_sb_info
stat_open	./debug.c	/^static int stat_open(struct inode *inode, struct file *file)$/;"	f	file:
stat_show	./debug.c	/^static int stat_show(struct seq_file *s, void *v)$/;"	f	file:
state	./node.h	/^	int state;		\/* in use or not: NID_NEW or NID_ALLOC *\/$/;"	m	struct:free_nid
stop_gc_thread	./gc.c	/^void stop_gc_thread(struct f2fs_sb_info *sbi)$/;"	f
store	./super.c	/^	ssize_t (*store)(struct f2fs_attr *, struct f2fs_sb_info *,$/;"	m	struct:f2fs_attr	file:
str2hashbuf	./hash.c	/^static void str2hashbuf(const unsigned char *msg, size_t len,$/;"	f	file:
struct_type	./super.c	/^	int struct_type;$/;"	m	struct:f2fs_attr	file:
submit_dummy_page	./segment.c	/^static inline void submit_dummy_page(struct f2fs_sb_info *sbi, struct f2fs_io_info* fio,$/;"	f	file:
sum_blk	./segment.h	/^	struct f2fs_summary_block *sum_blk;	\/* cached summary block *\/$/;"	m	struct:curseg_info	typeref:struct:curseg_info::f2fs_summary_block
sum_blk_addr	./segment.h	/^static inline block_t sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)$/;"	f
sync_dirty_dir_inodes	./checkpoint.c	/^void sync_dirty_dir_inodes(struct f2fs_sb_info *sbi)$/;"	f
sync_inode_page	./node.c	/^void sync_inode_page(struct dnode_of_data *dn)$/;"	f
sync_meta_pages	./checkpoint.c	/^long sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,$/;"	f
sync_node_pages	./node.c	/^int sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,$/;"	f
test_opt	./f2fs.h	54;"	d
tot_blks	./f2fs.h	/^	int tot_blks, data_blks, node_blks;$/;"	m	struct:f2fs_stat_info
tot_segs	./f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
total_count	./f2fs.h	/^	int total_count, utilization;$/;"	m	struct:f2fs_stat_info
total_ext	./f2fs.h	/^	int hit_ext, total_ext;$/;"	m	struct:f2fs_stat_info
total_hit_ext	./f2fs.h	/^	int total_hit_ext, read_hit_ext;	\/* extent cache hit ratio *\/$/;"	m	struct:f2fs_sb_info
total_node_count	./f2fs.h	/^	unsigned int total_node_count;		\/* total node block count *\/$/;"	m	struct:f2fs_sb_info
total_sections	./f2fs.h	/^	unsigned int total_sections;		\/* total section count *\/$/;"	m	struct:f2fs_sb_info
total_valid_block_count	./f2fs.h	/^	block_t total_valid_block_count;	\/* # of valid blocks *\/$/;"	m	struct:f2fs_sb_info
total_valid_inode_count	./f2fs.h	/^	unsigned int total_valid_inode_count;	\/* valid inode count *\/$/;"	m	struct:f2fs_sb_info
total_valid_node_count	./f2fs.h	/^	unsigned int total_valid_node_count;	\/* valid node block count *\/$/;"	m	struct:f2fs_sb_info
trim_end	./f2fs.h	/^	__u64 trim_end;$/;"	m	struct:cp_control
trim_minlen	./f2fs.h	/^	__u64 trim_minlen;$/;"	m	struct:cp_control
trim_start	./f2fs.h	/^	__u64 trim_start;$/;"	m	struct:cp_control
trimmed	./f2fs.h	/^	__u64 trimmed;$/;"	m	struct:cp_control
truncate_blocks	./file.c	/^int truncate_blocks(struct inode *inode, u64 from, bool lock)$/;"	f
truncate_data_blocks	./file.c	/^void truncate_data_blocks(struct dnode_of_data *dn)$/;"	f
truncate_data_blocks_range	./file.c	/^int truncate_data_blocks_range(struct dnode_of_data *dn, int count)$/;"	f
truncate_dnode	./node.c	/^static int truncate_dnode(struct dnode_of_data *dn)$/;"	f	file:
truncate_hole	./file.c	/^int truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)$/;"	f
truncate_inline_data	./inline.c	/^void truncate_inline_data(struct inode *inode, u64 from)$/;"	f
truncate_inode_blocks	./node.c	/^int truncate_inode_blocks(struct inode *inode, pgoff_t from)$/;"	f
truncate_node	./node.c	/^static void truncate_node(struct dnode_of_data *dn)$/;"	f	file:
truncate_nodes	./node.c	/^static int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,$/;"	f	file:
truncate_partial_data_page	./file.c	/^static void truncate_partial_data_page(struct inode *inode, u64 from)$/;"	f	file:
truncate_partial_nodes	./node.c	/^static int truncate_partial_nodes(struct dnode_of_data *dn,$/;"	f	file:
truncate_xattr_node	./node.c	/^int truncate_xattr_node(struct inode *inode, struct page *page)$/;"	f
try_to_free_nats	./node.c	/^int try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)$/;"	f
type	./f2fs.h	/^	enum page_type type;	\/* contains DATA\/NODE\/META\/META_FLUSH *\/$/;"	m	struct:f2fs_io_info	typeref:enum:f2fs_io_info::page_type
type	./segment.h	/^	unsigned char type;		\/* segment type like CURSEG_XXX_TYPE *\/$/;"	m	struct:seg_entry
unblock_operations	./checkpoint.c	/^static void unblock_operations(struct f2fs_sb_info *sbi)$/;"	f	file:
update_dent_inode	./dir.c	/^int update_dent_inode(struct inode *inode, const struct qstr *name)$/;"	f
update_dirty_page	./checkpoint.c	/^void update_dirty_page(struct inode *inode, struct page *page)$/;"	f
update_extent_cache	./data.c	/^void update_extent_cache(block_t blk_addr, struct dnode_of_data *dn)$/;"	f
update_general_status	./debug.c	/^static void update_general_status(struct f2fs_sb_info *sbi)$/;"	f	file:
update_inode	./inode.c	/^void update_inode(struct inode *inode, struct page *node_page)$/;"	f
update_inode_page	./inode.c	/^void update_inode_page(struct inode *inode)$/;"	f
update_mem_info	./debug.c	/^static void update_mem_info(struct f2fs_sb_info *sbi)$/;"	f	file:
update_nats_in_cursum	./f2fs.h	/^static inline int update_nats_in_cursum(struct f2fs_summary_block *rs, int i)$/;"	f
update_parent_metadata	./dir.c	/^static void update_parent_metadata(struct inode *dir, struct inode *inode,$/;"	f	file:
update_sit_entry	./segment.c	/^static void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)$/;"	f	file:
update_sit_info	./debug.c	/^static void update_sit_info(struct f2fs_sb_info *sbi)$/;"	f	file:
update_sits_in_cursum	./f2fs.h	/^static inline int update_sits_in_cursum(struct f2fs_summary_block *rs, int i)$/;"	f
user_block_count	./f2fs.h	/^	block_t user_block_count;		\/* # of user blocks *\/$/;"	m	struct:f2fs_sb_info
util_free	./f2fs.h	/^	int util_free, util_valid, util_invalid;$/;"	m	struct:f2fs_stat_info
util_invalid	./f2fs.h	/^	int util_free, util_valid, util_invalid;$/;"	m	struct:f2fs_stat_info
util_valid	./f2fs.h	/^	int util_free, util_valid, util_invalid;$/;"	m	struct:f2fs_stat_info
utilization	./f2fs.h	/^	int total_count, utilization;$/;"	m	struct:f2fs_stat_info
utilization	./segment.h	/^static inline int utilization(struct f2fs_sb_info *sbi)$/;"	f
v_ops	./segment.h	/^	const struct victim_selection *v_ops;	\/* victim selction operation *\/$/;"	m	struct:dirty_seglist_info	typeref:struct:dirty_seglist_info::victim_selection
valid_blocks	./segment.h	/^	unsigned int valid_blocks;	\/* # of valid blocks in a section *\/$/;"	m	struct:sec_entry
valid_blocks	./segment.h	/^	unsigned short valid_blocks;	\/* # of valid blocks *\/$/;"	m	struct:seg_entry
valid_count	./f2fs.h	/^	unsigned int valid_count, valid_node_count, valid_inode_count;$/;"	m	struct:f2fs_stat_info
valid_inode_count	./f2fs.h	/^	unsigned int valid_count, valid_node_count, valid_inode_count;$/;"	m	struct:f2fs_stat_info
valid_inode_count	./f2fs.h	/^static inline unsigned int valid_inode_count(struct f2fs_sb_info *sbi)$/;"	f
valid_node_count	./f2fs.h	/^	unsigned int valid_count, valid_node_count, valid_inode_count;$/;"	m	struct:f2fs_stat_info
valid_node_count	./f2fs.h	/^static inline unsigned int valid_node_count(struct f2fs_sb_info *sbi)$/;"	f
valid_user_blocks	./f2fs.h	/^static inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)$/;"	f
validate_checkpoint	./checkpoint.c	/^static struct page *validate_checkpoint(struct f2fs_sb_info *sbi,$/;"	f	file:
ver_after	./f2fs.h	56;"	d
verify_block_addr	./segment.h	/^static inline void verify_block_addr(struct f2fs_sb_info *sbi, block_t blk_addr)$/;"	f
version	./node.h	/^	unsigned char version;	\/* version of the node *\/$/;"	m	struct:node_info
vfs_inode	./f2fs.h	/^	struct inode vfs_inode;		\/* serve a vfs inode *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::inode
victim_secmap	./segment.h	/^	unsigned long *victim_secmap;		\/* background GC victims *\/$/;"	m	struct:dirty_seglist_info
victim_sel_policy	./segment.h	/^struct victim_sel_policy {$/;"	s
victim_selection	./segment.h	/^struct victim_selection {$/;"	s
wait	./f2fs.h	/^	struct completion wait;$/;"	m	struct:flush_cmd	typeref:struct:flush_cmd::completion
wait_io	./f2fs.h	/^	struct completion *wait_io;		\/* for completion bios *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::completion
wait_on_all_pages_writeback	./checkpoint.c	/^static void wait_on_all_pages_writeback(struct f2fs_sb_info *sbi)$/;"	f	file:
wait_on_node_pages_writeback	./node.c	/^int wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f
winode_slab	./gc.c	/^static struct kmem_cache *winode_slab;$/;"	v	typeref:struct:kmem_cache	file:
write_all_xattrs	./xattr.c	/^static inline int write_all_xattrs(struct inode *inode, __u32 hsize,$/;"	f	file:
write_checkpoint	./checkpoint.c	/^void write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f
write_compacted_summaries	./segment.c	/^static void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)$/;"	f	file:
write_data_page	./segment.c	/^void write_data_page(struct page *page, struct dnode_of_data *dn,$/;"	f
write_data_summaries	./segment.c	/^void write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)$/;"	f
write_io	./f2fs.h	/^	struct f2fs_bio_info write_io[NR_PAGE_TYPE];	\/* for write bios *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_bio_info
write_meta_page	./segment.c	/^void write_meta_page(struct f2fs_sb_info *sbi, struct page *page)$/;"	f
write_node_page	./segment.c	/^void write_node_page(struct f2fs_sb_info *sbi, struct page *page,$/;"	f
write_node_summaries	./segment.c	/^void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)$/;"	f
write_normal_summaries	./segment.c	/^static void write_normal_summaries(struct f2fs_sb_info *sbi,$/;"	f	file:
write_orphan_inodes	./checkpoint.c	/^static void write_orphan_inodes(struct f2fs_sb_info *sbi, block_t start_blk)$/;"	f	file:
write_sum_page	./segment.c	/^static void write_sum_page(struct f2fs_sb_info *sbi,$/;"	f	file:
writepages	./f2fs.h	/^	struct mutex writepages;		\/* mutex for writepages() *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::mutex
written_block_count	./segment.h	/^static inline block_t written_block_count(struct f2fs_sb_info *sbi)$/;"	f
written_valid_blocks	./segment.h	/^	block_t written_valid_blocks;	\/* # of valid blocks in main area *\/$/;"	m	struct:sit_info
xattr_ver	./f2fs.h	/^	unsigned long long xattr_ver;	\/* cp version of xattr modification *\/$/;"	m	struct:f2fs_inode_info
zone	./segment.h	/^	unsigned int zone;			\/* current zone number *\/$/;"	m	struct:curseg_info
